<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Here. There.</title>
  
  <subtitle>Love ice cream. Love sunshine. Love life. Love the world. Love myself. Love you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://godbasin.github.io/"/>
  <updated>2020-07-05T03:13:05.687Z</updated>
  <id>https://godbasin.github.io/</id>
  
  <author>
    <name>被删</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VSCode 源码解读：事件系统设计</title>
    <link href="https://godbasin.github.io/2020/07/05/vscode-event/"/>
    <id>https://godbasin.github.io/2020/07/05/vscode-event/</id>
    <published>2020-07-05T01:55:29.000Z</published>
    <updated>2020-07-05T03:13:05.687Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究前端大型项目中要怎么管理满天飞的事件、模块间各种显示和隐式调用的问题，本文结合相应的源码分析，记录 VS Code 中的事件管理系统设计。</p><a id="more"></a><h1 id="VS-Code-事件"><a href="#VS-Code-事件" class="headerlink" title="VS Code 事件"></a>VS Code 事件</h1><p>看源码的方式有很多种，带着疑问有目的性地看，会简单很多。</p><h2 id="Q1-VS-Code-中的事件管理代码在哪？"><a href="#Q1-VS-Code-中的事件管理代码在哪？" class="headerlink" title="Q1: VS Code 中的事件管理代码在哪？"></a>Q1: VS Code 中的事件管理代码在哪？</h2><p>一般来说，说到事件，肯定是跟<code>event</code>关键字相关，因此我们直接全局搜一下文件名（VS Code 下快捷键<code>ctrl+p</code>）:<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/vscode-event-file-name.png" alt=""></p><p>一下子就出来了，这个路径是<code>base\common\event.ts</code>的肯定是比较关键的。打开一看，里面比较关键的有两个：<strong>Event</strong>和<strong>Emitter</strong>。</p><h2 id="Q2-VS-Code-中的事件都包括了哪些能力？"><a href="#Q2-VS-Code-中的事件都包括了哪些能力？" class="headerlink" title="Q2: VS Code 中的事件都包括了哪些能力？"></a>Q2: VS Code 中的事件都包括了哪些能力？</h2><p>先来看看<code>Event</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 主要定义了一些接口协议，以及相关方法</span></div><div class="line"><span class="comment">// 使用 namespace 的方式将相关内容包裹起来</span></div><div class="line"><span class="keyword">export</span> namespace Event &#123;</div><div class="line">  <span class="comment">// 来看看里面比较关键的一些方法</span></div><div class="line"></div><div class="line">  <span class="comment">// 给定一个事件，返回另一个仅触发一次的事件</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">once</span>&lt;<span class="title">T</span>&gt;(<span class="params">event: Event&lt;T&gt;</span>): <span class="title">Event</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 给定一连串的事件处理功能（过滤器，映射等），每个事件和每个侦听器都将调用每个函数</span></div><div class="line">  <span class="comment">// 对事件链进行快照可以使每个事件每个事件仅被调用一次</span></div><div class="line">  <span class="comment">// 以此衍生了 map、forEach、filter、any 等方法此处省略</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">snapshot</span>&lt;<span class="title">T</span>&gt;(<span class="params">event: Event&lt;T&gt;</span>): <span class="title">Event</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 给事件增加防抖</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>&lt;<span class="title">T</span>&gt;(<span class="params">event: Event&lt;T&gt;, merge: (last: T | undefined, event: T</span>) =&gt; <span class="title">T</span>, <span class="title">delay</span>?: <span class="title">number</span>, <span class="title">leading</span>?: <span class="title">boolean</span>, <span class="title">leakWarningThreshold</span>?: <span class="title">number</span>): <span class="title">Event</span>&lt;<span class="title">T</span>&gt;;</span></div><div class="line"></div><div class="line">  // 触发一次的事件，同时包括触发时间</div><div class="line">  <span class="title">export</span> <span class="title">function</span> <span class="title">stopwatch</span>&lt;<span class="title">T</span>&gt;(<span class="params">event: Event&lt;T&gt;</span>): <span class="title">Event</span>&lt;<span class="title">number</span>&gt; &#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 仅在 event 元素更改时才触发的事件</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">latch</span>&lt;<span class="title">T</span>&gt;(<span class="params">event: Event&lt;T&gt;</span>): <span class="title">Event</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 缓冲提供的事件，直到出现第一个 listener，这时立即触发所有事件，然后从头开始传输事件</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">buffer</span>&lt;<span class="title">T</span>&gt;(<span class="params">event: Event&lt;T&gt;, nextTick = false, _buffer: T[] = []</span>): <span class="title">Event</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 可链式处理的事件，支持以下方法</span></div><div class="line">  <span class="keyword">export</span> interface IChainableEvent&lt;T&gt; &#123;</div><div class="line">    <span class="attr">event</span>: Event&lt;T&gt;;</div><div class="line">    map&lt;O&gt;<span class="function">(<span class="params">fn: (i: T</span>) =&gt;</span> O): IChainableEvent&lt;O&gt;;</div><div class="line">    forEach(fn: <span class="function">(<span class="params">i: T</span>) =&gt;</span> <span class="keyword">void</span>): IChainableEvent&lt;T&gt;;</div><div class="line">    filter(fn: <span class="function">(<span class="params">e: T</span>) =&gt;</span> boolean): IChainableEvent&lt;T&gt;;</div><div class="line">    filter&lt;R&gt;<span class="function">(<span class="params">fn: (e: T | R</span>) =&gt;</span> e is R): IChainableEvent&lt;R&gt;;</div><div class="line">    reduce&lt;R&gt;<span class="function">(<span class="params">merge: (last: R | <span class="literal">undefined</span>, event: T</span>) =&gt;</span> R, initial?: R): IChainableEvent&lt;R&gt;;</div><div class="line">    latch(): IChainableEvent&lt;T&gt;;</div><div class="line">    debounce(merge: <span class="function">(<span class="params">last: T | <span class="literal">undefined</span>, event: T</span>) =&gt;</span> T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent&lt;T&gt;;</div><div class="line">    debounce&lt;R&gt;<span class="function">(<span class="params">merge: (last: R | <span class="literal">undefined</span>, event: T</span>) =&gt;</span> R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent&lt;R&gt;;</div><div class="line">    on(listener: <span class="function">(<span class="params">e: T</span>) =&gt;</span> any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;</div><div class="line">    once(listener: <span class="function">(<span class="params">e: T</span>) =&gt;</span> any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;</div><div class="line">  &#125;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ChainableEvent</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">IChainableEvent</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 将事件转为可链式处理的事件</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">chain</span>&lt;<span class="title">T</span>&gt;(<span class="params">event: Event&lt;T&gt;</span>): <span class="title">IChainableEvent</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 来自 DOM 事件的事件</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fromDOMEventEmitter</span>&lt;<span class="title">T</span>&gt;(<span class="params">emitter: DOMEventEmitter, eventName: string, map: (...args: any[]</span>) =&gt; <span class="title">T</span> = <span class="title">id</span> =&gt; <span class="title">id</span>): <span class="title">Event</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 来自 Promise 的事件</span></div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fromPromise</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params">promise: Promise&lt;T&gt;</span>): <span class="title">Event</span>&lt;<span class="title">undefined</span>&gt; </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们能看到，<code>Event</code>中主要是一些对事件的处理和某种类型事件的生成。其中，除了常见的<code>once</code>和 DOM 事件等兼容，还提供了比较丰富的事件能力：</p><ul><li>防抖动</li><li>可链式调用</li><li>缓存</li><li>Promise 转事件</li></ul><h2 id="Q3-VS-Code-中的事件的触发和监听是怎么实现的？"><a href="#Q3-VS-Code-中的事件的触发和监听是怎么实现的？" class="headerlink" title="Q3: VS Code 中的事件的触发和监听是怎么实现的？"></a>Q3: VS Code 中的事件的触发和监听是怎么实现的？</h2><p>到这里，我们只看到了关于事件的一些功能（参考<code>Event</code>），而事件的触发和监听又是怎么进行的呢？</p><p>我们可以继续来看<code>Emitter</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是事件发射器的一些生命周期和设置</span></div><div class="line"><span class="keyword">export</span> interface EmitterOptions &#123;</div><div class="line">  onFirstListenerAdd?: <span class="built_in">Function</span>;</div><div class="line">  onFirstListenerDidAdd?: <span class="built_in">Function</span>;</div><div class="line">  onListenerDidAdd?: <span class="built_in">Function</span>;</div><div class="line">  onLastListenerRemove?: <span class="built_in">Function</span>;</div><div class="line">  leakWarningThreshold?: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">// 可传入生命周期方法和设置</span></div><div class="line">  <span class="keyword">constructor</span>(options?: EmitterOptions) &#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 允许大家订阅此发射器的事件</span></div><div class="line">  get event(): Event&lt;T&gt; &#123;</div><div class="line">    <span class="comment">// 此处会根据传入的生命周期相关设置，在对应的场景下调用相关的生命周期方法</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 向订阅者触发事件</span></div><div class="line">  fire(event: T): <span class="keyword">void</span> &#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 清理相关的 listener 和队列等</span></div><div class="line">  dispose() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，<code>Emitter</code>以<code>Event</code>为对象，以简洁的方式提供了事件的订阅、触发、清理等能力。</p><h2 id="Q4-项目中的事件是怎么管理的？"><a href="#Q4-项目中的事件是怎么管理的？" class="headerlink" title="Q4: 项目中的事件是怎么管理的？"></a>Q4: 项目中的事件是怎么管理的？</h2><p><code>Emitter</code>似乎有些简单了，我们只能看到单个事件发射器的使用。那各个模块之间的事件订阅和触发又是怎么实现的呢？</p><p>我们来全局搜一下关键字<code>Emitter</code>:<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/vscode-event-global-emitter.jpg" alt=""></p><p>搜出来很多地方都有使用，我们来看一下第一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里我们只摘录相关的代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowManager</span> </span>&#123;</div><div class="line">  public <span class="keyword">static</span> readonly INSTANCE = <span class="keyword">new</span> WindowManager();</div><div class="line">  <span class="comment">// 注册一个事件发射器</span></div><div class="line">  private readonly _onDidChangeZoomLevel = <span class="keyword">new</span> Emitter&lt;number&gt;();</div><div class="line">  <span class="comment">// 将该发射器允许大家订阅的事件取出来</span></div><div class="line">  public readonly onDidChangeZoomLevel: Event&lt;number&gt; = <span class="keyword">this</span>._onDidChangeZoomLevel.event;</div><div class="line"></div><div class="line">  public setZoomLevel(zoomLevel: number, <span class="attr">isTrusted</span>: boolean): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._zoomLevel === zoomLevel) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>._zoomLevel = zoomLevel;</div><div class="line">    <span class="comment">// 当 zoomLevel 有变更时，触发该事件</span></div><div class="line">    <span class="keyword">this</span>._onDidChangeZoomLevel.fire(<span class="keyword">this</span>._zoomLevel);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>显然，在 VS Code 里，事件的使用方式主要包括：</p><ul><li>注册事件发射器</li><li>对外提供定义的事件</li><li>在特定时机向订阅者触发事件</li></ul><p>那么，其他地方又是怎样订阅这么一个事件呢？在这个例子中，由于浏览器实例唯一，可以通过挂载全局对象的方式来提供使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对外提供一个调用全局实例的方法</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onDidChangeZoomLevel</span>(<span class="params">callback: (zoomLevel: number</span>) =&gt; <span class="title">void</span>): <span class="title">IDisposable</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> WindowManager.INSTANCE.onDidChangeZoomLevel(callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 其他地方的调用方式</span></div><div class="line"><span class="keyword">import</span> &#123; onDidChangeZoomLevel &#125; <span class="keyword">from</span> <span class="string">'vs/base/browser/browser'</span>;</div><div class="line"><span class="keyword">let</span> zoomListener = onDidChangeZoomLevel(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 该干啥干啥</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>除此之外，我们也可以通过创建实例调用来直接监听相关事件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> WindowManager(opts);</div><div class="line">instance.onDidChangeZoomLevel(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 该干啥干啥</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="Q5-事件满天飞，不会导致性能问题吗？"><a href="#Q5-事件满天飞，不会导致性能问题吗？" class="headerlink" title="Q5: 事件满天飞，不会导致性能问题吗？"></a>Q5: 事件满天飞，不会导致性能问题吗？</h2><p>习惯使用一些前端框架的小伙伴们肯定比较有经验，我们如果在某个组件里做了事件订阅这样的操作，当组件销毁的时候是需要取消事件订阅的。否则该订阅内容会在内存中一直存在，除了一些异常问题，还可能引起内存泄露。</p><p>那么，VS Code 里又是怎么处理这样的问题呢？</p><p>其实我们在全局搜<code>Emitter</code>的时候，也能看到一些地方的使用方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只选取局部关键代码摘要</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Scrollable</span> <span class="keyword">extends</span> <span class="title">Disposable</span> </span>&#123;</div><div class="line">  private _onScroll = <span class="keyword">this</span>._register(<span class="keyword">new</span> Emitter&lt;ScrollEvent&gt;());</div><div class="line">  public readonly onScroll: Event&lt;ScrollEvent&gt; = <span class="keyword">this</span>._onScroll.event;</div><div class="line"></div><div class="line">  private _setState(newState: ScrollState): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="keyword">const</span> oldState = <span class="keyword">this</span>._state;</div><div class="line">    <span class="keyword">if</span> (oldState.equals(newState)) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>._state = newState;</div><div class="line">    <span class="comment">// 状态变更的时候，触发事件</span></div><div class="line">    <span class="keyword">this</span>._onScroll.fire(<span class="keyword">this</span>._state.createScrollEvent(oldState));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用了<code>this._register(new Emitter&lt;T&gt;())</code>这样的方式注册事件发射器，我们能看到该方法继承自<code>Disposable</code>。而<code>Disposable</code>的实现也很简洁:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">Disposable</span> <span class="title">implements</span> <span class="title">IDisposable</span> </span>&#123;</div><div class="line">  <span class="comment">// 用一个 Set 来存储注册的事件发射器</span></div><div class="line">  private readonly _store = <span class="keyword">new</span> DisposableStore();</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    trackDisposable(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 处理事件发射器</span></div><div class="line">  public dispose(): <span class="keyword">void</span> &#123;</div><div class="line">    markTracked(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._store.dispose();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 注册一个事件发射器</span></div><div class="line">  protected _register&lt;T extends IDisposable&gt;(t: T): T &#123;</div><div class="line">    <span class="keyword">if</span> ((t <span class="keyword">as</span> unknown <span class="keyword">as</span> Disposable) === <span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot register a disposable on itself!'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._store.add(t);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是说，每个继承<code>Disposable</code>类都会有管理事件发射器的相关方法，包括添加、销毁处理等。其实我们仔细看看，这个<code>Disposable</code>并不只是服务于事件发射器，它适用于所有支持<code>dispose()</code>方法的对象：</p><blockquote><p>Dispose 模式主要用来资源管理，资源比如内存被对象占用，则会通过调用方法来释放。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> interface IDisposable &#123;</div><div class="line">  dispose(): <span class="keyword">void</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DisposableStore</span> <span class="title">implements</span> <span class="title">IDisposable</span> </span>&#123;</div><div class="line">  private _toDispose = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;IDisposable&gt;();</div><div class="line">  private _isDisposed = <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 处置所有注册的 Disposable，并将其标记为已处置</span></div><div class="line">  <span class="comment">// 将来添加到此对象的所有 Disposable 都将在 add 中处置。</span></div><div class="line">  public dispose(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._isDisposed) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    markTracked(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>._isDisposed = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">this</span>.clear();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 丢弃所有已登记的 Disposable，但不要将其标记为已处置</span></div><div class="line">  public clear(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="keyword">this</span>._toDispose.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.dispose());</div><div class="line">    <span class="keyword">this</span>._toDispose.clear();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 添加一个 Disposable</span></div><div class="line">  public add&lt;T extends IDisposable&gt;(t: T): T &#123;</div><div class="line">    markTracked(t);</div><div class="line">    <span class="comment">// 如果已处置，则不添加</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._isDisposed) &#123;</div><div class="line">      <span class="comment">// 报错提示之类的</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 未处置，则可添加</span></div><div class="line">      <span class="keyword">this</span>._toDispose.add(t);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此，我们可以看到，在 VS Code 中是这样管理事件的：</p><ol><li>抹平 DOM 事件等差异，提供标准化的<code>Event</code>和<code>Emitter</code>能力。</li><li>通过注册<code>Emitter</code>，并对外提供类似生命周期的方法<code>onXxxxx</code>的方式，来进行事件的订阅和监听。</li><li>通过提供通用类<code>Disposable</code>，统一管理多个事件发射器（或其他资源）的注册、销毁。</li></ol><h2 id="Q6-上面只销毁了事件触发器本身的资源，那对于订阅者来说，要怎么销毁订阅的-Listener-呢？"><a href="#Q6-上面只销毁了事件触发器本身的资源，那对于订阅者来说，要怎么销毁订阅的-Listener-呢？" class="headerlink" title="Q6: 上面只销毁了事件触发器本身的资源，那对于订阅者来说，要怎么销毁订阅的 Listener 呢？"></a>Q6: 上面只销毁了事件触发器本身的资源，那对于订阅者来说，要怎么销毁订阅的 Listener 呢？</h2><p>或许读到这里的时候，你依然有点懵。看上去 VS Code 的<code>Emitter</code>和<code>Event</code>似乎跟常见的实现方式很相似，只是使用的方式有点不一样而已，到底有什么特别的呢？</p><p>不知道大家注意到了没，在 VS Code 中，注册一个事件发射器、订阅某个事件，都是通过<code>this._register()</code>这样的方式来实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 注册事件发射器</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Disposable</span> </span>&#123;</div><div class="line">  <span class="comment">// 注册一个事件发射器，可使用 this._onDidClick.fire(xxx) 来触发事件</span></div><div class="line">  private _onDidClick = <span class="keyword">this</span>._register(<span class="keyword">new</span> Emitter&lt;Event&gt;());</div><div class="line">  get onDidClick(): BaseEvent&lt;Event&gt; &#123; <span class="keyword">return</span> <span class="keyword">this</span>._onDidClick.event; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 订阅某个事件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickInputController</span> <span class="keyword">extends</span> <span class="title">Disposable</span> </span>&#123;</div><div class="line">  <span class="comment">// 省略很多其他非关键代码</span></div><div class="line">  private getUI() &#123;</div><div class="line">    <span class="keyword">const</span> ok = <span class="keyword">new</span> Button(okContainer);</div><div class="line">    ok.label = localize(<span class="string">'ok'</span>, <span class="string">"OK"</span>);</div><div class="line">    <span class="comment">// 注册一个 Disposable，用来订阅某个事件</span></div><div class="line">    <span class="keyword">this</span>._register(ok.onDidClick(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.onDidAcceptEmitter.fire();</div><div class="line">    &#125;));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是说当某个类被销毁时，会发生以下事情：</p><ol><li>它所注册的事件发射器会被销毁，而事件发射器中的 Listener、队列等都会被清空。</li><li>它所订阅的一些事件会被销毁，订阅中的 Listener 同样会被移除。</li></ol><p>至于订阅事件的 Listener 是如何被移除的，可参考以下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  get event(): Event&lt;T&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._event) &#123;</div><div class="line">      <span class="keyword">this</span>._event = <span class="function">(<span class="params">listener: (e: T</span>) =&gt;</span> any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) =&gt; &#123;</div><div class="line">        <span class="comment">// 若无队列，则新建一个</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>._listeners) &#123;</div><div class="line">          <span class="keyword">this</span>._listeners = <span class="keyword">new</span> LinkedList();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 往队列中添加该 Listener，同时返回一个移除该 Listener 的方法</span></div><div class="line">        <span class="keyword">const</span> remove = <span class="keyword">this</span>._listeners.push(!thisArgs ? listener : [listener, thisArgs]);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> result: IDisposable;</div><div class="line">        <span class="comment">// 返回一个带 dispose 方法的结果，dispose 执行时会移除该 Listener</span></div><div class="line">        result = &#123;</div><div class="line">          <span class="attr">dispose</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            result.dispose = Emitter._noop;</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>._disposed) &#123;</div><div class="line">              remove();</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">if</span> (disposables <span class="keyword">instanceof</span> DisposableStore) &#123;</div><div class="line">          disposables.add(result);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(disposables)) &#123;</div><div class="line">          disposables.push(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._event;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到这里，VS Code 中事件相关的管理的设计也都呈现出来了，包括：</p><ul><li>提供标准化的<code>Event</code>和<code>Emitter</code>能力</li><li>通过注册<code>Emitter</code>，并对外提供类似生命周期的方法<code>onXxxxx</code>的方式，来进行事件的订阅和监听</li><li>通过提供通用类<code>Disposable</code>，统一管理相关资源的注册和销毁</li><li>通过使用同样的方式<code>this._register()</code>注册事件和订阅事件，将事件相关资源的处理统一挂载到<code>dispose()</code>方法中</li></ul><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>VS Code 中除了事件的管理，Dispose 模式还体现在各种其他资源的管理，包括插件等。</p><p>当我们遇到一些问题不知道该怎么解决的时候，可以试着站到巨人的肩膀上，说不定可以看到更多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究前端大型项目中要怎么管理满天飞的事件、模块间各种显示和隐式调用的问题，本文结合相应的源码分析，记录 VS Code 中的事件管理系统设计。&lt;/p&gt;
    
    </summary>
    
      <category term="前端解决方案" scheme="https://godbasin.github.io/categories/%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="逻辑实现" scheme="https://godbasin.github.io/tags/%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>响应式编程在前端领域的应用</title>
    <link href="https://godbasin.github.io/2020/07/04/reactive-programing/"/>
    <id>https://godbasin.github.io/2020/07/04/reactive-programing/</id>
    <published>2020-07-04T04:03:21.000Z</published>
    <updated>2020-07-05T03:11:17.250Z</updated>
    
    <content type="html"><![CDATA[<p>其实在几年前因为 Angular 的原因接触过响应式编程，而这些年的一些项目经验，让我在再次回顾响应式编程的时候又有了新的理解。</p><a id="more"></a><h1 id="什么是响应式编程"><a href="#什么是响应式编程" class="headerlink" title="什么是响应式编程"></a>什么是响应式编程</h1><p>响应式编程基于观察者模式，是一种面向数据流和变化传播的声明式编程方式。</p><h2 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a>异步数据流</h2><p>响应式编程常常用在异步数据流，通过订阅某个数据流，可以对数据进行一系列流式处理，例如过滤、计算、转换、合流等，配合函数式编程可以实现很多优秀的场景。</p><p>除了天然异步的前端、客户端等 GUI 开发以外，响应式编程在大数据处理中也同样拥有高并发、分布式、依赖解耦等优势，在这种同步阻塞转异步的并发场景下会有较大的性能提升，淘宝业务架构就是使用响应式的架构。</p><h2 id="响应式编程在前端领域"><a href="#响应式编程在前端领域" class="headerlink" title="响应式编程在前端领域"></a>响应式编程在前端领域</h2><p>在前端领域，常见的异步编程场景包括事件处理、用户输入、HTTP 响应等。对于这类型的数据流，可以使用响应式编程的方式来进行设计。</p><p>不少开发者基于响应式编程设计了一些工具库，包括 Rxjs、Mobx、Cycle.js 等。其中，Rxjs 提供了基于可观察对象（Observable）的 functional reactive programming 服务，Mobx 提供了基于状态管理的 transparent functional reactive programming 服务，而 Cycle.js 则是一个响应式前端框架。</p><p>我们可以结合具体场景来介绍下使用，这里会以 Rxjs 来说明。</p><h3 id="HTTP-请求与重试"><a href="#HTTP-请求与重试" class="headerlink" title="HTTP 请求与重试"></a>HTTP 请求与重试</h3><p>基于响应式编程，我们可以很简单地实现一个请求的获取和自动重试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">"rxjs/ajax"</span>;</div><div class="line"><span class="keyword">import</span> &#123; map, retry, catchError &#125; <span class="keyword">from</span> <span class="string">"rxjs/operators"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">"/api/data"</span>).pipe(</div><div class="line">  <span class="comment">// 可以在 catchError 之前使用 retry 操作符。它会订阅到原始的来源可观察对象，此处为重新发起 HTTP 请求</span></div><div class="line">  retry(<span class="number">3</span>), <span class="comment">// 失败前会重试最多 3 次</span></div><div class="line">  map(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!res.response) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Value expected!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.response;</div><div class="line">  &#125;),</div><div class="line">  catchError(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="keyword">of</span>([]))</div><div class="line">);</div><div class="line"></div><div class="line">apiData.subscribe(&#123;</div><div class="line">  next(x) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"data: "</span>, x);</div><div class="line">  &#125;,</div><div class="line">  error(err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"errors already caught... will not run"</span>);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><p>对应用户的一些交互，也可以通过订阅的方式来获取需要的信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> observable = Rx.Observable.fromEvent(input, <span class="string">"input"</span>) <span class="comment">// 监听 input 元素的 input 事件</span></div><div class="line">  .map(<span class="function">(<span class="params">e</span>) =&gt;</span> e.target.value) <span class="comment">// 一旦发生，把事件对象 e 映射成 input 元素的值</span></div><div class="line">  .filter(<span class="function">(<span class="params">value</span>) =&gt;</span> value.length &gt;= <span class="number">1</span>) <span class="comment">// 接着过滤掉值长度小于 1 的</span></div><div class="line">  .distinctUntilChanged() <span class="comment">// 如果该值和过去最新的值相等，则忽略</span></div><div class="line">  .subscribe(</div><div class="line">    <span class="comment">// subscribe 拿到数据</span></div><div class="line">    (x) =&gt; <span class="built_in">console</span>.log(x),</div><div class="line">    (err) =&gt; <span class="built_in">console</span>.error(err)</div><div class="line">  );</div><div class="line"><span class="comment">// 订阅</span></div><div class="line">observable.subscribe(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure><p>在用户频繁交互的场景，数据的流式处理可以让我们很方便地进行节流和防抖。除此之外，模块间的调用和事件通信同样可以通过这种方式来进行处理。</p><h2 id="比较其他技术"><a href="#比较其他技术" class="headerlink" title="比较其他技术"></a>比较其他技术</h2><p>接触响应式编程这个概念的时候，大多数人都会对它产生困惑，也比较容易与 Promise、事件订阅这些设计混淆。我们来一起看看。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 相信大家也都很熟悉，在这里拿出来比较，其实更多是将 Rxjs 中的 Observable 与之比较。这两个其实很不一样：</p><ul><li>Promise 会发生状态扭转，状态扭转不可逆；而 Observable 是无状态的，数据流可以源源不断，可用于随着时间的推移获取多个值</li><li>Promise 在定义时就会被执行；而 Observable 只有在被订阅时才会执行</li><li>Promise 不支持取消；而 Observable 可通过取消订阅取消正在进行的工作</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>同样是基于观察者模式，相信很多人都对事件和响应式编程之间的关系比较迷惑。而根据具体的设计实现，事件和响应式编程模式可以达到高度相似。</p><p>一个比较显著的区别在于，由于响应式编程是面向数据流和变化传播的模式，意味着我们可以对数据流进行配置处理，使其在把事件传给事件处理器之前先进行转换。同样由于流式处理，响应式编程可以把包含一堆异步/事件的组合从开头到结尾用流的操作符清晰表示，而原始事件回调只能表示一堆相邻节点的关系，对于数据流动方向和过程都可以进一步掌握。</p><p>同时，结合响应式编程的合流、缓存等能力，我们可以收获更多。</p><h1 id="响应式编程提供了怎样的服务"><a href="#响应式编程提供了怎样的服务" class="headerlink" title="响应式编程提供了怎样的服务"></a>响应式编程提供了怎样的服务</h1><p>前面说了很多，相信大家对响应式编程的概念和使用有一定的理解了。现在，我们一起来看看它还能给我们带来怎样的服务。</p><h2 id="热观察与冷观察"><a href="#热观察与冷观察" class="headerlink" title="热观察与冷观察"></a>热观察与冷观察</h2><p>在 Rxjs 中，有热观察和冷观察的概念。其中的区别：</p><ul><li>Hot Observable，可以理解为现场直播，我们进场的时候只能看到即时的内容</li><li>Cold Observable，可以理解为点播（电影），我们打开的时候会从头播放</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> liveStreaming$ = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">liveStreaming$.subscribe(</div><div class="line">  <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'subscriber from first second'</span>)</div><div class="line">  err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</div><div class="line">)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  liveStreaming$.subscribe(</div><div class="line">    <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'subscriber from 2nd second'</span>)</div><div class="line">    err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</div><div class="line">  )</div><div class="line">&#125;, <span class="number">2000</span>)</div><div class="line"><span class="comment">// 事实上两个订阅者接收到的值都是 0,1,2,3,4，此处为冷观察</span></div></pre></td></tr></table></figure><p>Rxjs 中 Observable 默认为冷观察，而通过<code>publish()</code>和<code>connect()</code>可以将冷的 Observable 转变成热的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> publisher$ = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">5</span>).publish();</div><div class="line"></div><div class="line">publisher$.subscribe(</div><div class="line">  <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'subscriber from first minute'</span>,data),</div><div class="line">  err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</div><div class="line">)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    publisher$.subscribe(</div><div class="line">        <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'subscriber from 2nd minute'</span>, data),</div><div class="line">        err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">        () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</div><div class="line">    )</div><div class="line">&#125;, <span class="number">3000</span>)</div><div class="line"></div><div class="line">publisher$.connect();</div><div class="line"><span class="comment">// 第一个订阅者输出的是0,1,2,3,4，而第二个输出的是3,4，此处为热观察</span></div></pre></td></tr></table></figure><p>热观察和冷观察根据具体的场景可能会有不同的需要，而 Observable 提供的缓存能力也能解决不少业务场景。例如，如果我们想要在拉群后，自动同步之前的聊天记录，通过冷观察就可以做到。同样的，热观察的用途也很广泛。</p><h2 id="合流"><a href="#合流" class="headerlink" title="合流"></a>合流</h2><p>流的处理大概是响应式编程中最有意思的部分了。一般来说，合流有两种方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. merge</span></div><div class="line">--1----2-----3--------4---</div><div class="line">---<span class="_">-a</span>-----b----c--<span class="_">-d</span>------</div><div class="line">           merge</div><div class="line">--1<span class="_">-a</span>--2--b--3-c--<span class="_">-d</span>--4---</div><div class="line"></div><div class="line"><span class="comment"># 2. combine</span></div><div class="line">--1----2-----3--------4---</div><div class="line">---<span class="_">-a</span>-----b-----c-<span class="_">-d</span>------</div><div class="line">         combine</div><div class="line">----1a-2a-2b-3b-3c-3d-4d--</div></pre></td></tr></table></figure><p>那这样的合流方式，可以具体应用到哪里呢？</p><p>例如，merge 的合流方式可以用在群聊天、聊天室，一些多人协作的场景、公众号订阅的场景就可以通过这样的方式合流，最终按照顺序地展示出对应的操作记录。</p><p>再举个例子，我们在 Excel 中，通过函数计算了 A1 和 B2 两个格子的相加。这种情况下，使用 combine 方式合流符合预期，那么我们可以订阅这么一个流：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> streamA1 = Rx.Observable.fromEvent(inputA1, <span class="string">"input"</span>); <span class="comment">// 监听 A1 单元格的 input 事件</span></div><div class="line"><span class="keyword">const</span> streamB2 = Rx.Observable.fromEvent(inputB2, <span class="string">"input"</span>); <span class="comment">// 监听 B2 单元格的 input 事件</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> subscribe = combineLatest(streamA1, streamB2).subscribe(<span class="function">(<span class="params">valueA1, valueB2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 从 streamA1 和 streamB2 中获取最新发出的值</span></div><div class="line">    <span class="keyword">return</span> valueA1 + valaueB2;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 获取函数计算结果</span></div><div class="line">observable.subscribe(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure><p>在一个较大型的前端应用中，通常会拆分成渲染层、数据层、网络层、其他服务等多个功能模块。虽然服务按照功能结构进行拆分了，但依然会存在服务间调用导致依赖关系复杂、事件触发和监听满天飞等情况，这种情况下，只能通过全局搜索关键字来找到上下游数据流、信息流，通过一个接一个的节点和关键字搜索才能大概理清楚某个数据来源哪里。</p><p>那么，如果使用了响应式编程，我们可以通过各种合流的方式、订阅分流的方式，来将应用中的数据流动从头到尾串在一起。这样，我们可以很清晰地当前节点上的数据来自于哪里，是用户的操作还是来自网络请求。</p><h2 id="其他使用方式"><a href="#其他使用方式" class="headerlink" title="其他使用方式"></a>其他使用方式</h2><p>除了上面提到的一些 HTTP 请求、用户操作、事件管理等可以使用响应式编程的方式来实现，我们还可以将定时器、数组/可迭代对象变量转换为可观察序列。</p><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>也就是说，如果我们界面中有个倒计时，就可以以定时器为数据源，订阅该数据流进行响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// timerOne 在 0 秒时发出第一个值，然后每 1 秒发送一次</span></div><div class="line"><span class="keyword">const</span> timerOne = timer(<span class="number">0</span>, <span class="number">1000</span>).subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 触发界面更新</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>定时器结合合流的方式，我们还可以玩出更多的花样。例如，界面中有三个倒计时，我们需要在倒计时全部结束之后展示一些内容，这个时候我们就可以通过将三个倒计时 combine 合流，当三个流都处于倒计时终止的状态时，触发相应的逻辑。</p><h3 id="数组-可迭代对象"><a href="#数组-可迭代对象" class="headerlink" title="数组/可迭代对象"></a>数组/可迭代对象</h3><p>我们可以将数组或者可迭代的对象，转换为可观察的序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// 打印出每个项目</span></div><div class="line"><span class="keyword">const</span> subscription = Rx.Observable.from(array).subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">    e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure><p>乍一看，似乎只是将遍历换了种写法，其实这样的能力可以用在更多的地方。例如，我们在离线编辑文档的时候，做了很多操作，这些操作在本地会用一个操作记录数组的方式缓存下来。当应用检测到网络状态恢复的时候，可以将这样的操作组转换为有序的一个个操作同步到远程服务器。（当然，更好的设计应该是支持批量有序地上传操作到服务器）</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>对响应式编程的介绍暂告一段落。</p><p>可见对于很多复杂程度较低的前端应用来说，其实入门成本比较高。但在一些复杂应用的场景，合理地使用响应式编程，可以有效地降低各个模块间的依赖，更加容易地进行整体数据流动管理和维护。</p><p>这么有意思的东西，你要不要来试试看？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实在几年前因为 Angular 的原因接触过响应式编程，而这些年的一些项目经验，让我在再次回顾响应式编程的时候又有了新的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端解决方案" scheme="https://godbasin.github.io/categories/%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="逻辑实现" scheme="https://godbasin.github.io/tags/%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>谈谈依赖和解耦</title>
    <link href="https://godbasin.github.io/2020/06/26/module-seperate/"/>
    <id>https://godbasin.github.io/2020/06/26/module-seperate/</id>
    <published>2020-06-26T02:55:23.000Z</published>
    <updated>2020-06-26T03:10:31.509Z</updated>
    
    <content type="html"><![CDATA[<p>大型项目总避免不了各种模块间相互依赖，如果模块之间耦合严重，随着功能的增加，项目到后期会越来越难以维护。今天我们一起来思考下，大家常说的代码解耦到底要怎么做？<br><a id="more"></a></p><h1 id="依赖是怎么产生的"><a href="#依赖是怎么产生的" class="headerlink" title="依赖是怎么产生的"></a>依赖是怎么产生的</h1><p>既然要研究怎么让模块解耦，那当然要从根源来分析：依赖它到底从何而来？</p><p>依赖其实是在我们想把代码写好的那一刻开始产生的。为什么这么说呢？因为大多数代码都是可以通过像流水线一样写下来，最终变成一个几千行的函数、几万行的单个文件。这个时候甚至没有拆分成模块，也就更谈不上所谓依赖和解耦了。</p><p>忽然有一天，我们发现这种堆屎山的日子实在过的没有意思，开始研究怎么将一座大屎山拆成几个小屎山，然后再一点点清理干净。依赖的产生，就在我们一拆多的这个过程伴随出现的。</p><h2 id="接口管理"><a href="#接口管理" class="headerlink" title="接口管理"></a>接口管理</h2><p>当我们开始进行代码优化的时候，最先想到的就是将某些通用的功能抽象成单独的模块，通过提供接口这样的方式来给到需要的地方使用。</p><p>为了避免过度设计，我们会基于现有和可预见的需要进行设计。但日常的开发中，不可预见的问题定位和调整却占了大部分的时间。</p><p>例如，在做 To B 项目的时候，我们设计了一套完整的 API 给到对方，开始的时候大家都会按照这套接口来配合开发，其乐融融。突然有一天，老板拉了一个大客户，说这个客户的用户量会很大，必须要好好配合。老板一走，大客户马上化身甲方爸爸，说他们的接口已经写好了，友商都是按照他们的格式接入，都上线了。</p><p>遇到这种情况，通常我们会新增一个适配层，专门用于我们的服务和甲方爸爸之间的适配。</p><p>说了那么多，依赖在哪里呢？</p><p>依赖其实在接口设计完成的时候就出来了，虽然这是我们自己设计的接口，但它依赖于上游按照约定来调用。而上游有调整的时候，我们是需要跟随者适配或者调整的。</p><p>或者举个小一点的例子，我们在项目中使用了一个较出名的开源库。某一天该开源库升级版本了，新的版本不兼容旧的版本，同时声明旧的版本不会再继续维护了。这意味着如果我们不升级版本的话，后续旧的版本出现了 bug，我们只能自己啃源码来修复了。</p><p>这是来自于“甲方按照约定接口来调用服务”、“乙方按照约定接口来提供服务”的依赖。</p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>由接口管理产生的依赖通常来自外部，而应用内部也会有依赖的产生，常见的包括状态管理和事件管理。我们先来看看状态管理。</p><p>一个应用程序能按照预期正常运行，必然无法避免一些状态的管理。最简单的，生命周期就是一种状态。程序是否已经启动、功能是否正常运行、输入输出是否有变化，这些都会影响到程序的运行状态。</p><p>由于程序会有状态变化，因此我们的功能实现必然依赖程序的状态。例如，只有用户登录了才能进行更多的操作、订单产生了才可以进行撤销、界面渲染完成了用户才可以点击，等等。</p><p>从代码可读性和可维护性角度来看，面向对象编程近些年来还是稍胜于函数式编程，面向对象的设计本身就是状态设计的过程，而某个对象的运行结果，也会依赖于该对象的状态。</p><p>这是来自于对某个程序“按照预期运行”进行合理设计而产生的依赖。</p><h2 id="功能管理"><a href="#功能管理" class="headerlink" title="功能管理"></a>功能管理</h2><p>当我们根据功能将代码拆分成一个个模块之后，功能模块的管理也同样会产生一些依赖。</p><p>管理系统中最常见的就是面板的管理，对于每个面板来说，它应该只关心自身的状态。产品设计会要求我们在打开某个新的面板的时候，关闭其他面板；或是在点击面板以外的地方，关闭当前面板。这会涉及到面板与面板以外界面的通信，一般来说我们可以使用事件的方式来管理。每个面板在创建的时候，都需要监听外界的一个点击事件，并判断点击区域落在面板外面的时候，触发关闭。</p><p>某一天，产品提了个需求，所有的这些面板关闭的时候都要有一个动画效果，至于这个关闭动画的持续时间，要根据点击位置与面板的距离来计算。我们需要在点击事件触发的时候，把点击的位置告诉监听对象。</p><p>于是，我们全局搜了所有该类型事件的触发节点和监听节点，一一进行调整。</p><p>这是来自于对某个功能“不会发生变更”而产生的依赖。</p><h2 id="依赖来自于约束"><a href="#依赖来自于约束" class="headerlink" title="依赖来自于约束"></a>依赖来自于约束</h2><p>为了方便管理，我们设计了一些约定，并基于“大家都会遵守约定”的前提来提供更好、更便捷的服务。</p><p>举个例子，前端框架中为了更清晰地管理渲染层、数据层和逻辑处理，常用的设计包括 MVC、MVVM 等。而要使这样的架构设计发挥出效果，我们需要遵守其中的使用规范，不可以在数据层里直接修改界面等。</p><p>可以看到，依赖来自于对代码的设计。</p><h1 id="依赖可以解耦吗"><a href="#依赖可以解耦吗" class="headerlink" title="依赖可以解耦吗"></a>依赖可以解耦吗</h1><p>既然依赖来自于设计，为什么我们又常常说要进行模块间的解耦，降低模块间的依赖呢？</p><h2 id="依赖的划分"><a href="#依赖的划分" class="headerlink" title="依赖的划分"></a>依赖的划分</h2><p>我们先来看看一个问题，所有的依赖都需要解耦吗？</p><p>其实我们能看到，不合理的设计会导致代码间相互依赖，耦合严重。这种情况下，我们可以理解为产生了不合适的依赖。</p><p>而通常我们所说的设计解耦，则是通过合理的设计，恰到好处的职责和边界划分。此时，同样会产生一些约定，但这样的约定可以更好地管理我们的代码，此时可以理解为产生了合理的依赖。</p><p>因此，回到前面的疑问：既然依赖来自于设计，为什么我们要通过设计来降低依赖呢？显然，我们想要减少的，是不合理的依赖。而通过合理的设计，可以进行恰当的解耦。</p><h3 id="无状态的函数式编程？"><a href="#无状态的函数式编程？" class="headerlink" title="无状态的函数式编程？"></a>无状态的函数式编程？</h3><p>每个程序员对函数式编程都曾抱有过幻想，写多了面向对象编程的代码，对一些状态的管理和维护感到心烦。而无状态的函数式仿佛是白月光，可远观不可亵玩。</p><p>但即使是基于函数式编程设计的语言，写出来的功能也无法逃脱状态管理的命运。像 Clojure 编写的 Storm，也需要进行消息队列的管理、重启后服务的恢复等一系列状态管理。</p><p>在前端领域，React 同样基于函数式编程，但框架同样带有生命周期这样的状态。用 React 来实现的应用也依赖状态，因此同样产生了 Redux/Mobx 这样的工具来进行数据状态的管理工具。</p><p>应用程序无法离开状态的管理，是否意味着我们不需要函数式编程呢？并不是这样的。相反，我们需要对功能模块进行划分，划分出有状态和无状态的功能，来将状态管理放置到更小的范围，避免“牵一发而动全身”。</p><p>在这里，我们进行了状态有无的划分。</p><h3 id="单向流的数据管理？"><a href="#单向流的数据管理？" class="headerlink" title="单向流的数据管理？"></a>单向流的数据管理？</h3><p>代码解耦的方式，其中也包括了使用单向数据流这种方式。</p><p>不管是 React 还是 Vue，都提供了单向数据流的管理工具。由于一个应用中，各个功能间都会有一些相互间的数据依赖，为了避免模块间的直接依赖，使用单向流的方式，可以将一些非模块内闭环的数据通过有序、单向的方式进行捆绑。通过这样的方式，模块之间的依赖解除了，调整为模块与数据流模块之间的依赖，代码的耦合程度得到缓解。</p><p>在这里，我们进行了模块内外数据的划分。</p><h3 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h3><p>服务化，是系统解耦最常用的一种方式。</p><p>通过将功能进行业务领域的拆分，我们得到了不同领域的服务，常见的例如电商系统拆分成订单系统、购物车系统、商品系统、商家系统、支付系统等等。</p><p>而如今打得火热的“微服务”，也都是基于领域建模的一种实现方式。</p><p>在这里，我们进行了业务领域的划分。</p><h3 id="模块化与依赖注入？"><a href="#模块化与依赖注入？" class="headerlink" title="模块化与依赖注入？"></a>模块化与依赖注入？</h3><p>相比于针对系统设计的服务化，同样有针对功能设计的模块化。</p><p>在前端领域，同样可以根据功能拆分为表单功能、列表功能、面板功能等，通过给这些功能设置边界、封装成独立完整的模块，可以将功能与功能之间的依赖降到最低。同样的，根据功能划分的方式，我们还可以将功能拆分成渲染层、数据层、网络层这样的模块。</p><p>而配合依赖注入的方式，我们在使用这些功能的时候不再需要单独对这些功能的状态进行维护，同样实现了功能模块间的解耦。</p><p>在这里，我们进行了功能应用的划分。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>到这里，你会不会有点疑惑，说了半天好像什么都没说？我当然知道要合理设计啊，但什么才是合理的设计呢？</p><p>架构设计没有银弹，系统的复杂度、使用场景、用户群体、机器性能等都会影响决策，“具体场景具体分析”才是最优解。</p><p>而我们能做的，就是多思考、多参考、多分析、多尝试，沉淀下来的经验和思考方式才是最实用的工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大型项目总避免不了各种模块间相互依赖，如果模块之间耦合严重，随着功能的增加，项目到后期会越来越难以维护。今天我们一起来思考下，大家常说的代码解耦到底要怎么做？&lt;br&gt;
    
    </summary>
    
      <category term="前端解决方案" scheme="https://godbasin.github.io/categories/%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="逻辑实现" scheme="https://godbasin.github.io/tags/%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>大型前端项目要怎么跟踪和分析函数调用链</title>
    <link href="https://godbasin.github.io/2020/06/21/trace-stash/"/>
    <id>https://godbasin.github.io/2020/06/21/trace-stash/</id>
    <published>2020-06-21T06:41:31.000Z</published>
    <updated>2020-06-21T06:42:54.833Z</updated>
    
    <content type="html"><![CDATA[<p>相信不少有大型项目维护经验的小伙伴，都曾经遇到代码量太多、函数调用链路太长、断点断到头都要断等等问题。最近也在研究解决这个问题，本文分享下整体的思路和解决方案。<br><a id="more"></a></p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>简单做一个函数耗时分析的功能还是比较简单的，写代码也是比较容易的一部分。但如果让一个功能真正发挥它的价值，前期方案的设计和分析也是很重要的。</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>一般来说，对于大型项目或是新人加入，维护过程（熟悉代码、定位问题、性能优化等）比较痛的有以下问题：</p><ul><li><strong>函数执行情况黑盒</strong><ul><li>函数调用链不清晰</li><li>函数耗时不清楚</li><li>代码异常定位困难</li></ul></li><li><strong>用户行为难以复现</strong></li></ul><p>要是遇到代码稍微复杂点，事件比较多、函数调用也特别多的，即使使用断点也能看到眼花，蒸汽眼罩都得多买一些（真的贵啊）。生活本来就比较难了，身为技术人的我们得用技术去提升下自身的生活和工作体验呀。</p><p>回到上面说到的现状，函数执行黑盒这块相信大家都比较容易考虑到，而在日常的问题定位中，很多情况下我们需要查用户的问题，但是用户的反馈常常表达上会和我们理解的不一致。那如果能直接还原用户的操作，那岂不是棒棒哒？</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>那既然现状有了，我们可以根据自己的需要，把目标确定下来。</p><blockquote><p>个人觉得，即使是技术人员，前期的目标和现状分析也是很重要的。我们常常会遇到很多项目进行到一半发现和预期不一致、需要重新返工甚至只能放弃，往往是因为前期做的调研不充分，考虑到的情况还不够多。综上，设计的部分也需要好好去做，至于具体的方式，是手稿、文字、流程图、还是 PPT，可以根据个人喜好去选择。</p></blockquote><p>那么，我先来拆分下自己想要的功能是什么样子的：</p><ul><li>基础能力<ul><li>单个函数执行情况：函数名、入参、出参、耗时</li><li>全局辅助信息：函数调用链、调用次数统计</li></ul></li><li>便捷接入<ul><li>不改动源码</li></ul></li><li>易拓展<ul><li>可重放功能</li><li>可保存到服务器</li></ul></li></ul><p>首先，基本功能必不可少，主要包括函数的一些执行情况，例如调用链、函数名、类名、入参出参，还有性能分析相关的，包括耗时、函数调用次数的统计等。这些在我们分析和定位问题的时候，能派上不少的用场。</p><p>其次，对于这部分功能代码，需要满足易用性，包括易接入、易拓展等。易接入主要考虑不需要改动源代码，这也是代码设计中比较基础的要求了。易拓展则预留给后续想要在现有功能基础上添加新功能的时候，会相对简便。</p><h3 id="整体方案设计"><a href="#整体方案设计" class="headerlink" title="整体方案设计"></a>整体方案设计</h3><p>方案设计也不算复杂，基本上就是结合目标，然后以自己最熟练的方向作为起点，一点点把完整的功能视图补全。最后，再回顾下前面的现状和目标，分析设计出来的方案是否有脱离实际需要（有时候我们的脑补能力很强大，容易飘离本意）。</p><p>说起函数，最简单的就是给每个想要检测的函数包裹一层，除了调用原有的功能以外，新增对函数的一些数据采集，包括上面说到的单个函数执行信息和全局的辅助信息等。</p><p>要怎么方便地使用这些信息呢？我们可以通过堆栈的方式存下来，然后对这些信息进行处理来获取调用链、耗时等。通常来说，可以暴露全局变量的接口，来快速打印输出这些信息。</p><p>我们来看看设计方案：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/function-trace-global.png" alt=""></p><p>这里，将函数重放和上传服务器的优先级降低，先实现核心功能。工作内容的拆分、工作量的预估这些也都是方案设计中比较重要的部分，将大目标拆分成一个个小目标，这样对整体节奏、实现过程的把控会更有力。</p><h3 id="方案细节设计"><a href="#方案细节设计" class="headerlink" title="方案细节设计"></a>方案细节设计</h3><p>整体方案初步定了，我们需要考虑每个环节的细节方案。以一期的功能为主，流程包括以下：<br><strong>1. 监听函数执行</strong>。<br><strong>2. 采集函数执行情况</strong>：（调用链路、入参出参、耗时）。<br><strong>3. 暴露全局变量或 API</strong>。<br><strong>4. 使用全局变量或 API 打印调用链等</strong>。</p><p>由于这是一个非关键链路的功能，除了怎样的功能更方便使用以外，主要考虑这样的旁路功能不能影响主要功能的性能、不能因为一些异常导致正常功能无法使用。因此我们需要对每个流程进行一些分析和考虑：</p><ul><li>监听函数执行<ul><li>可通过依赖注入的方式，减少对源代码的入侵</li><li>代码实现多基于 Class，可考虑装饰器 Decorator 的方式</li></ul></li><li>采集函数执行情况<ul><li>需要注意性能和存储消耗，保证原有功能健壮性</li><li>考虑使用栈来存储<ul><li>存储考虑链路长度限制、参数长度限制、链路数量上限</li></ul></li><li>设置优先级，根据优先级选择性采集</li><li>旁路功能可考虑丢Worker执行<ul><li>考虑通信对性能的消耗</li></ul></li></ul></li></ul><p>我们能看到方案的一些细节如图：<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/function-trace-p0.png" alt=""></p><p>至此，大致的方案设计已经完成。</p><h2 id="函数调用链的设计和实现"><a href="#函数调用链的设计和实现" class="headerlink" title="函数调用链的设计和实现"></a>函数调用链的设计和实现</h2><p>其实对于函数耗时统计的，网上也有一大堆的代码可以搜到，其中基于装饰器实现的也很多。由于我们项目中代码大多数都是基于 Class 设计的，因此装饰器这种不影响源代码的方式更加适合。</p><h3 id="单次追踪对象"><a href="#单次追踪对象" class="headerlink" title="单次追踪对象"></a>单次追踪对象</h3><p>装饰器的实现其实不难，网上也有很多可以参考的。而我们装饰器里的具体逻辑是怎样的，依赖我们设计的单次追踪对象和调用栈是怎样的。因此，我们可以先设计一下单次追踪对象。</p><p>该对象要实现的功能包括：</p><ol><li><strong>特殊 ID 标记本追踪对象（<code>traceId</code>）</strong>。创建该次对象的时候，自动生成该 ID。</li><li><strong>可更新追踪对象的信息（<code>update</code>方法）</strong>。</li><li><strong>执行该追踪对象（<code>exec</code>方法）</strong>。为重放功能做铺垫，如果我们存储了该函数以及函数入参，理想情况下可认为该函数可重放</li><li><strong>打印该追踪对象相关信息（<code>print</code>方法）</strong>。</li></ol><p>来，直接看大致的代码设计：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">interface IFunctionTraceInfo &#123;</div><div class="line">    className?: string; <span class="comment">// 类名</span></div><div class="line">    functionName?: string; <span class="comment">// 函数名</span></div><div class="line">    inParams?: any[] | <span class="literal">null</span>; <span class="comment">// 入参</span></div><div class="line">    outParams?: any[] | <span class="literal">null</span>; <span class="comment">// 出参</span></div><div class="line">    timeConsuming?: number; <span class="comment">// 耗时</span></div><div class="line">    originFunction?: <span class="built_in">Function</span>; <span class="comment">// 原函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionTrace</span> </span>&#123;</div><div class="line">    traceId: string; <span class="comment">// 标记本次Trace</span></div><div class="line">    traceInfo: IFunctionTraceInfo;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(traceInfo: IFunctionTraceInfo) &#123;</div><div class="line">        <span class="keyword">this</span>.traceId = <span class="keyword">this</span>.getRandomId();</div><div class="line">        <span class="keyword">this</span>.traceInfo = traceInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 随机生成一个 ID 来标记</span></div><div class="line">    getRandomId() &#123;</div><div class="line">        <span class="comment">// 时间戳（9位） + 随机串（10位）</span></div><div class="line">        <span class="keyword">return</span> (<span class="built_in">Date</span>.now()).toString(<span class="number">32</span>) + <span class="built_in">Math</span>.random().toString(<span class="number">32</span>).substring(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新该函数的一些信息</span></div><div class="line">    update(traceInfo: IFunctionTraceInfo) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 执行该函数</span></div><div class="line">    exec() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 打印该函数的一些信息</span></div><div class="line">    print() &#123;</div><div class="line">        <span class="keyword">const</span> &#123; className, functionName, timeConsuming &#125; = <span class="keyword">this</span>.traceInfo;</div><div class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;className&#125;</span> -&gt; <span class="subst">$&#123;functionName&#125;</span>(<span class="subst">$&#123;<span class="keyword">this</span>.traceId&#125;</span>): <span class="subst">$&#123;timeConsuming&#125;</span>`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="追踪堆栈"><a href="#追踪堆栈" class="headerlink" title="追踪堆栈"></a>追踪堆栈</h3><p>除了单次的追踪堆栈，我们还需要根据函数执行的顺序等维护完整的调用链信息，因此我们需要一个堆栈来维护完整的调用链。</p><p>那么，这个堆栈的功能也应该包括：</p><ol><li><strong>当前的层次（<code>level</code>）</strong>。为调用链做铺垫，可认为函数开始执行的时候<code>level++</code>，函数结束的时候<code>level--</code>。<ul><li>当多个函数交错执行的时候（例如事件触发），该方式可能不准确</li></ul></li><li><strong>堆栈信息（<code>traceList</code>）</strong>。</li><li><strong>开始记录某次追踪（<code>start</code>方法）</strong>。添加该次追踪之后将<code>level++</code>，便于记录当前追踪的层次。</li><li><strong>结束记录某次追踪（<code>end</code>方法）</strong>。<code>level--</code>。</li><li><strong>获取某次追踪对象（<code>getTrace</code>方法）</strong>。可用于单次追踪对象的信息获取和操作。</li><li><strong>打印堆栈信息</strong>。结合当前层次，通过缩放打印对应的调用信息，可包括耗时等。</li><li><strong>打印堆栈中函数的调用次数</strong>。以调用次数该维度打印堆栈中的追踪信息，可用于分析函数调用次数是否符合预期。</li></ol><p>同样的，我们来看看代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">interface StashFunctionTrace &#123;</div><div class="line">    traceLevel?: number;</div><div class="line">    trace: FunctionTrace;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionTraceStash</span> </span>&#123;</div><div class="line">    level: number; <span class="comment">// 当前层级，默认为0</span></div><div class="line">    traceList: StashFunctionTrace[]; <span class="comment">// Trace数组</span></div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">this</span>.level = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.traceList = [];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 开始本次 Trace</span></div><div class="line">    <span class="comment">// 添加该 Trace 之后将 level + 1，便于记录当前 Trace 的层次</span></div><div class="line">    start(trace: FunctionTrace) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 结束本次 Trace</span></div><div class="line">    end() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据 traceId 获取某个 Trace 对象</span></div><div class="line">    getTrace(traceId: string): StashFunctionTrace | <span class="literal">null</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.traceList.find(<span class="function">(<span class="params">stashTrace</span>) =&gt;</span> stashTrace.trace.traceId === traceId) || <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 打印 Trace 堆栈信息</span></div><div class="line">    printTraceList(): string &#123;</div><div class="line">        <span class="keyword">const</span> traceStringList: string[] = [];</div><div class="line">        <span class="keyword">this</span>.traceList.forEach(<span class="function">(<span class="params">stashTrace</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> prefix = <span class="string">''</span>;</div><div class="line">            <span class="keyword">if</span> (stashTrace.traceLevel &amp;&amp; stashTrace.traceLevel &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 根据层次，前置 tab</span></div><div class="line">                prefix = <span class="keyword">new</span> <span class="built_in">Array</span>(stashTrace.traceLevel).join(<span class="string">'\t'</span>);</div><div class="line">            &#125;</div><div class="line">            traceStringList.push(prefix + stashTrace.trace.print());</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> traceStringList.join(<span class="string">'\n'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 打印函数调用次数统计</span></div><div class="line">    printTraceCount(className?: string, functionName?: string) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重放该堆栈</span></div><div class="line">    replay() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清空该堆栈信息</span></div><div class="line">    clear() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="装饰器逻辑"><a href="#装饰器逻辑" class="headerlink" title="装饰器逻辑"></a>装饰器逻辑</h3><p>到这里，我们可以确定装饰器需要进行哪些操作：</p><ol><li>生成追踪记录<code>new Trace(执行信息)</code>，包括入参、类名、方法名等。</li><li><code>TraceStash.add(Trace)</code>添加层次。</li><li><code>originFun()</code>包裹原有函数、执行。</li><li><code>Trace.update()</code>更新一些信息，包括函数耗时、出参等。</li><li><code>TraceStash.end()</code>结束本次调用。</li></ol><p>为了方便使用，我们可以设计基于<code>Class</code>的装饰器，以及基于<code>Class.methods</code>方法的装饰器，还可以基于单函数的装饰器。</p><p>我们还可以通过AST分析自动给代码中需要的部分添加上装饰器。至于装饰器具体实现，大家下来可以自己想一下。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>很多人喜欢拿了任务就直接开撸，然后就会在写代码的过程中发现一个又一个问题。幸运的话，最终能做出想要的效果。而运气不好的话，可能得推倒重来了。<br>而在开始写代码之前，稍微进行一些分析、思考和调研，可以得到事半功倍的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信不少有大型项目维护经验的小伙伴，都曾经遇到代码量太多、函数调用链路太长、断点断到头都要断等等问题。最近也在研究解决这个问题，本文分享下整体的思路和解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="前端解决方案" scheme="https://godbasin.github.io/categories/%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="逻辑实现" scheme="https://godbasin.github.io/tags/%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>多人协作如何进行冲突处理</title>
    <link href="https://godbasin.github.io/2020/06/14/operation-transform/"/>
    <id>https://godbasin.github.io/2020/06/14/operation-transform/</id>
    <published>2020-06-14T08:23:31.000Z</published>
    <updated>2020-06-14T15:06:03.805Z</updated>
    
    <content type="html"><![CDATA[<p>最近接触到一些针对多人同时操作进行冲突处理的场景，简单介绍下相关的实现方式。<br><a id="more"></a></p><h2 id="Operational-transformation-OT"><a href="#Operational-transformation-OT" class="headerlink" title="Operational transformation(OT)"></a>Operational transformation(OT)</h2><p>OT 算法最初是为在纯文本文档的协作编辑中的一致性维护和并发控制而发明的，在本文中我们也主要掌握一致性维护相关的一些方法。</p><h3 id="协同软件的冲突"><a href="#协同软件的冲突" class="headerlink" title="协同软件的冲突"></a>协同软件的冲突</h3><p>想必大家都知道，在多人协同场景下，必然会出现各种各样的冲突场景。</p><p>举个例子，团队接到一个超大型的项目需要开发，老板说10分钟给出排期和分工。然后瑟瑟发抖的大家二话不说打开腾讯文档，创建了一个表格，让每个模块负责人先针对自己模块来进行工作量拆分和预估。</p><p>PM 创建了表格之后，将表格丢到群里，说前端后台各自创建一个子表来写相应的工作量情况。</p><p>前端张三马上点开了表格，点击添加子表，系统自动生成“工作表2”这样一个子表。与此同时，后台李四也进行了同样的操作。</p><p>那么问题来了，一个表格中原则上并不允许两个同样名字的子表，这个时候冲突就出现了，我们要怎么处理呢？</p><p>虽然是两个同样名字的子表，但我们并不能将它们进行合并，因为对于张三和李四来说，他们就是在自己创建的子表里写工作拆分和排期情况。所以，我们需要使用对用户影响最小的方式，来解决掉这个冲突。</p><h3 id="操作的拆分"><a href="#操作的拆分" class="headerlink" title="操作的拆分"></a>操作的拆分</h3><p>为了处理冲突，我们需要将一些操作进行拆分。例如，我们插入一个子表这样一个操作，除了插入自身的操作，可能需要对其他子表进行移动操作。那么，对于一个子表来说，我们的操作可能会包括：</p><ul><li>插入</li><li>重命名</li><li>移动</li><li>删除</li><li>更新内容</li><li>…</li></ul><p>只要拆分得足够仔细，对于子表的所有用户行为，都可以由这些操作来组合成最终的效果。例如，复制粘贴一张子表，可以拆分为<code>插入-重命名-更新内容</code>；剪切一张子表，可以拆分为<code>插入-更新内容-删除-移动其他子表</code>。通过分析用户行为，我们可以提取出这些基本操作。</p><h3 id="操作间的冲突处理"><a href="#操作间的冲突处理" class="headerlink" title="操作间的冲突处理"></a>操作间的冲突处理</h3><p>基本操作提取出来之后，我们就可以很仔细地梳理和分析操作和操作之间是否会产生冲突，以及要怎么处理了。</p><p>例如，我们上面提取出来的关于子表的操作中，包括<code>插入</code>、<code>重命名</code>、<code>移动</code>、<code>删除</code>、<code>更新内容</code>五种操作，实际上，每种操作都可能和自身、以及其他四种操作都发生冲突，于是我们可能有<code>5*5=25</code>种需要考虑的冲突情况。</p><p>我们先来大致看看这 25 组冲突中，是不是全都需要进行冲突处理的。例如，<code>更新内容</code>一般来说跟其他几个操作都不会发生什么冲突，因为更新内容改变的是表格的内容，而不是位置、名字这些，一个表格内部和另一个表格内部基本上不会发生冲突。但<code>重命名</code>和<code>插入</code>之间，满足一定条件的时候（插入的子表名字和重命名的名字相同）可能就会产生冲突。</p><p>你可能会觉得疑惑，<code>插入-重命名</code>和<code>重命名-插入</code>不是一样的吗？我们先带着这个疑问继续往后看。</p><h3 id="最终一致性的实现"><a href="#最终一致性的实现" class="headerlink" title="最终一致性的实现"></a>最终一致性的实现</h3><p>说了那么多，看起来跟 OT 算法完全没有关系呀？？</p><p>OT 算法的一个核心目标，是实现最终一致性。为什么会有最终一致性的需求呢？</p><p>我们再看回张三和李四的例子，由于系统不允许存在有两个同样名称的子表，因此服务器会根据收到请求的顺序，将第二个子表进行重命名。假设张三的请求先到达服务端，那么李四创建的表格则需要被自动重命名为“工作表2（自动重命名）”。</p><p>为了让用户体验更流畅，我们在用户侧使用无锁、非阻塞的方式来进行协同。也就是对于李四来说，他已经创建了这样一个叫“工作表2”的子表了，由于网络延迟等原因可能还已经编辑上了。这时候服务端告诉李四，张三已经创建了一个“工作表2”的子表了，你自己看着办吧。</p><p>李四说，我已经编辑了这么多，你总不能让我全删掉重来吧。所以李四想了个办法，先将自己本地的表格<code>重命名</code>为”工作表2（自动重命名）”，然后将张三的子表<code>插入</code>。除此之外，由于自己的插入顺序在后面，还需要将自己的子表<code>移动</code>到后面一个位置。做完这些操作之后，李四告诉服务器，自己也<code>插入</code>了一个叫“工作表2（自动重命名）”的子表。</p><p>我们梳理下逻辑，可以得到：</p><ul><li>对于李四本地，需要进行的操作是：<code>重命名 + 插入 + 移动</code></li><li>对于服务器，需要进行的操作是：<code>插入</code>更新后的子表</li></ul><p>我们来看看这个 OT 算法的简略说明图：<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/google_ot.jpg" alt=""></p><p>我们代入到张三李四这个场景下：<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/sheet_ot.png" alt=""></p><p>可以看到，对于服务端来说，最终就是新增了两个子表，一个是张三的“工作表2”，另一个是李四的“工作表2（自动重命名）”。</p><p>除此之外，这个场景中还存在比较细致的时间问题。上面我们说李四收到服务器发来的张三的操作之后，在本地进行<code>重命名 + 插入 + 移动</code>，然后告诉服务器的操作是<code>插入</code>更新后的子表。但是还有个可能性，就是李四收到服务器的消息之前，就已经把自己<code>插入</code>“工作表2”的操作发出去给服务器了。这种情况下，服务器也需要具备处理冲突的能力，来维持最终一致性。</p><p>也就是说，我们在本地和服务器都有一套一致的冲突处理逻辑，才能保证算法的最终一致性。</p><p>但除了最终一致性，冲突处理还有其他很多需要考虑的场景，例如版本管理、性能问题等，后面有机会再慢慢介绍吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近接触到一些针对多人同时操作进行冲突处理的场景，简单介绍下相关的实现方式。&lt;br&gt;
    
    </summary>
    
      <category term="前端解决方案" scheme="https://godbasin.github.io/categories/%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="逻辑实现" scheme="https://godbasin.github.io/tags/%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--8.工作中的矛盾</title>
    <link href="https://godbasin.github.io/2020/04/18/about-front-end-8/"/>
    <id>https://godbasin.github.io/2020/04/18/about-front-end-8/</id>
    <published>2020-04-18T05:10:04.000Z</published>
    <updated>2020-04-18T05:15:31.793Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工作里，我们常常会遇到一些不如预期的事情。我们在做的常常又不全是自己想要做的事情，要怎么去理解和面对这样的矛盾呢？</p><a id="more"></a><h1 id="这不是我想做的"><a href="#这不是我想做的" class="headerlink" title="这不是我想做的"></a>这不是我想做的</h1><p>工作对于大多数的人来说，主要在于养家糊口。随着越来越多年轻人涌入程序员这个行业，大家的危机感慢慢浮现，想要保持竞争力、提升自我等念头让我们想得更多，也常常出现一些选择和矛盾的情况。</p><h2 id="业务需求-vs-技术需求"><a href="#业务需求-vs-技术需求" class="headerlink" title="业务需求 vs 技术需求"></a>业务需求 vs 技术需求</h2><p>做业务需求好，还是做技术需求好，大概是所有程序员都想过的事情，也是很多人会纠结的点。</p><p>一般来说，大家都会认为技术需求对个人的成长和提升帮助更大，同时技术需求也很少有业务面临的突发问题、外网投诉、活动发版等可能熬夜通宵的情况。而业务需求则有较可观的用户量，收益和稳定性可能会更好，但工作内容可能更偏向日常问题定位、产品需求的开发等“技术含量较低”的枯燥和重复性工作。</p><p>每天埋头写“差不多”代码的，羡慕做有挑战性的技术的。每天在做底层基础支撑的，苦恼于没有业务接入、团队面临调整等问题。</p><p>实际上业务需求也好，技术需求也好，我们都是在为某一个产品提供稳定、可靠的服务。对于业务来说，这个产品可能由产品经理提出需求而自己负责实现；而对于技术来说，这个产品则是由业务衍生出来的基础需求，需求的服务对象则是日常进行业务开发的人。</p><p>所有的技术需求都来源于业务的需要，自动化能力、灰度发布能力、监控告警能力、全链路跟踪能力等等，都是因为业务某个方面到达一定的瓶颈而提出的解决方案。</p><p>所以，对于做业务需求的小伙伴来说，需要关注到是什么导致了我们日常工作的枯燥，“重复性”的工作是否可以用工具解决？“相类似”的工作是否可以进行抽象然后提出解决方案？对于做业务的小伙伴来说，如果能积极思考和主动提出解决方案，也一样能获得很多的成长和机会。</p><p>对于做技术需求的小伙伴来说，需要关注我们正在做的事情，是否真的符合业务的需要？是可以让业务更加方便地使用，还是会给它们带来更多的麻烦？只有能贴切地解决业务的一些痛点，这样的技术方案才可能有更多的业务愿意接入，技术需求的意义才得以体现。</p><h2 id="ToB-vs-ToC"><a href="#ToB-vs-ToC" class="headerlink" title="ToB vs ToC"></a>ToB vs ToC</h2><p>对于前端同学来说，我们也常常会对 ToB 和 ToC 怎么选有过烦恼，其实区别更多在于用户群体和数量。</p><p>一般来说，ToB 的业务服务于某一类用户群体，因此会根据服务对象的不一样而工作重点有所区别。例如，如果服务于银行，则对技术方案要求严格，如果服务于政府机构，则可能需要兼容较低版本的 IE 浏览器，技术选型比较局限。但通常来说，ToB 业务的用户量并不会特别大，对性能要求较低，有些情况下也会由于机器部署环境封闭的原因，对网络和安全性要求较低，因此 ToB 业务可以更多关注开发效率提升、技术管理选型、项目可维护性等方面。</p><p>ToC 的业务用户量较大，对加载性能、浏览器兼容性等都要求很高，因此常常需要进行性能优化、兼容性检测、实时监控、SEO 优化等工作。</p><p>按理来说，在找工作的时候，ToC 业务的会比 ToB 业务的人优势要大一点，因为 ToC 对前端的各个角度要求都相对较高。但其实真正工作中，由于精力和工作内容分配的问题，很多参与 ToC 业务的人更多只关注自己负责的一小部分，因此其实并没有掌握到 ToC 业务的关键技术方案。而即使是在做 ToB 业务，也有不少小伙伴会有很多的时间去研究一些新技术、做很多的选型调研，也可以在这个过程中获得很好的成长。</p><p>所以，决定我们能否掌握更多的、成长更快的，最终还是一句话，要靠自己。</p><h2 id="全栈？"><a href="#全栈？" class="headerlink" title="全栈？"></a>全栈？</h2><p>如今随着 Node.js 的普及，也有不少的前端开发慢慢转型做全栈、大前端等方向。</p><p>的确，对于有全栈工作经验的人来说，找工作的时候会更吃香。但我们日常工作中是否都有机会去接触后台开发、客户端开发这些内容呢？我们是否一定需要有这样的工作经验才能获得更好的发展呢？</p><p>很多时候，前端由于入门简单的原因，很多的前端开发（包括我）都不是计算机专业出身。我们对于计算机基础、网络基础、算法和数据结构等内容掌握很少，更多时候是这些知识的缺乏阻碍了我们在程序员这一职业的发展，这也是为什么很多前端开发苦恼自己到达天花板，想着转型全栈或者后台就能走得更远。</p><p>这其实是个误区。后台开发由于开发语言、服务器管理、存储管理等工作内容的不一致，对于专业基础的要求更高，因此看上去似乎比前端能走得更远。但随着成熟的解决方案的出现，像分布式部署和管理、全链路跟踪等，以及运维和 DBA 等职位的出现、后台基本框架的完善，更多的后台开发技术选型的范围不大，在开发过程中也是偏向业务的开发，因此更多的关注点会落在业务风险梳理、问题定位和追踪、业务稳定性、效率提升等地方。而全栈中的后台开发，可能涉及的内容会更加局限一些。</p><p>所以，其实我们在日常工作中也可以更多地关注后台的实现和能力，除了可以更好地配合和理解后台的工作外，还可以提升自己对后台工作内容的理解。当然，最重要的其实依然是，我们需要扎实地补充计算机基础知识。</p><p>全栈开发经验可能让我们更容易地找到工作，但只有基础知识的掌握足够深入，才可以在接触后台开发、终端开发等内容的时候，有足够的能力去快速高效地解决问题。</p><h1 id="这不在我的工作范围内"><a href="#这不在我的工作范围内" class="headerlink" title="这不在我的工作范围内"></a>这不在我的工作范围内</h1><p>除了日常开发的内容，我们工作中也有不少其他各式各样的事情需要去做。有些人会想，我来这里并不是为了做这种事情，那么这种情况下要怎么处理呢？</p><h2 id="边缘工作该做吗？"><a href="#边缘工作该做吗？" class="headerlink" title="边缘工作该做吗？"></a>边缘工作该做吗？</h2><p>很多时候，我们所在的团队都会有很多边界不清晰、责任不明确的工作，例如会议纪要、值班查问题、组织团建等内容。一般来说组长调节好轮流负责是最好的，但事实上也有不少的团队会把这样的工作一直给到某个人，那么这样的情况要怎么处理呢？</p><p>大家都知道，这些工作会占用一些时间，而且经常需要做一些协调性的工作。如果你是一个希望专注技术成长的人，那想必会很烦恼。如果这种情况真的发生了，首先可以提出轮班的建议，如果老大觉得就是你做得最好一定要你做的话，可以尝试提升这部分工作的效率，同时把方案和步骤都写下来，再尝试让大家都参与进来。</p><p>那么如果其他人都真的“做不到”，你每天都得花上额外的时间来做的话，可以思考下自己能否承受得住这样的安排。这里的承受并不是指工作量太大，而是指个人对待这些事情的态度，毕竟如果给工作带来了情绪，才是最糟糕的结果。当然我们可以开放地接受最好，毕竟大多数人也只是来打份工的。</p><p>好的管理者会对一直承担边缘工作的小伙伴进行奖励，但也并不是全部都是这样的。实在不行的话，可以考虑再次反馈，最糟糕的情况下就得换个工作了。</p><h2 id="我该花时间在写-PPT-和文档上面吗"><a href="#我该花时间在写-PPT-和文档上面吗" class="headerlink" title="我该花时间在写 PPT 和文档上面吗"></a>我该花时间在写 PPT 和文档上面吗</h2><p>这大概是所有程序员都脑壳疼的问题了，但是它确实一个比其他所谓边缘工作都要现实的问题。</p><p>那么，我需要学好怎么写 PPT 吗？答案是要的。我们的 PPT 并不需要画的跟设计童鞋一样漂亮，大白字、表情包都可以往里面贴，重点只有一个：逻辑思路清晰。其实写 PPT、写文章和文档这些很难吗？不难，只是比较花时间。但是在写的过程其实你会进行很多的思考，会发现一些之前并没有考虑到的事情，同时也能锻炼你的书面表达能力。</p><p>所以，你依然需要花适当的时间去对你的项目进行设计、整理和复盘，用你擅长的形式，不管是 PPT 也好，文档、文章也好，将这些内容思路清晰地记录下来，才可以走得更远。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>工作里总有很多让人不舒服的事情，不过生活也是这样，大多数时候我们都无法改变环境，只能调整自己。让自己开心才是正经事！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常工作里，我们常常会遇到一些不如预期的事情。我们在做的常常又不全是自己想要做的事情，要怎么去理解和面对这样的矛盾呢？&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发月刊第15期（20200415）</title>
    <link href="https://godbasin.github.io/2020/04/15/wxapp-latest-20200415/"/>
    <id>https://godbasin.github.io/2020/04/15/wxapp-latest-20200415/</id>
    <published>2020-04-15T12:46:50.000Z</published>
    <updated>2020-04-18T05:17:30.603Z</updated>
    
    <content type="html"><![CDATA[<p>又一个月过去了，大家也快习惯了带着口罩上班，饭堂也在慢慢恢复菜单供打包，捡树枝活动异常火热，我们来看看小程序又更新了哪些能力吧~<br><a id="more"></a></p><h1 id="小程序-latest"><a href="#小程序-latest" class="headerlink" title="小程序 latest"></a>小程序 latest</h1><h2 id="小程序能力"><a href="#小程序能力" class="headerlink" title="小程序能力"></a>小程序能力</h2><h3 id="关于收回小程序”用户实名信息授权”接口的相关说明"><a href="#关于收回小程序”用户实名信息授权”接口的相关说明" class="headerlink" title="关于收回小程序”用户实名信息授权”接口的相关说明"></a>关于收回小程序”用户实名信息授权”接口的相关说明</h3><p>小程序将回收小程序“用户实名信息授权”接口，计划于2020年05月31日下线。对于以往已经接入了本接口的小程序，但依然有业务场景有相关需求，平台侧建设了替代接口方案——实名信息校验接口，提供给满足一定条件的业务方，相关接口：</p><ol><li>实名信息校验接口。</li></ol><ul><li>本接口可实现：在用户同意情况下，校验用户（或业务方）输入的实名信息是否正确（仅支持身份证信息）。对于接入微信城市服务的业务，或满足以下地址中的文档说明的范围，可以申请城市服务实名信息校验接口。</li><li><a href="https://developers.weixin.qq.com/community/business/doc/000e06614ac74068f3d9237eb5440d" target="_blank" rel="external">申请方式地址</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/cityservice/cityservice-checkrealnameinfo.html" target="_blank" rel="external">接口文档地址</a></li></ul><ol><li>地址组件接口。</li></ol><ul><li>本接口可实现：拉起微信原生的地址选择及编辑界面，可以编辑已有地址，也可以在编辑完成后，返回用户选择的地址。</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/address/wx.chooseAddress.html" target="_blank" rel="external">接口文档地址</a></li></ul><ol><li>快速填写组件接口。</li></ol><ul><li>本接口可实现： 小程序开发者可以获取用户首次填写过的表单的信息，并快速快速填充本次需要填写的表单。减少用户输入的压力。</li><li><a href="https://developers.weixin.qq.com/community/business/doc/0004c23556c43074dde973aeb5bc0d" target="_blank" rel="external">接口介绍、开放范围及申请指引</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/cityservice/cityservice-auto-fill.html" target="_blank" rel="external">接口文档地址</a></li></ul><h3 id="小程序测速功能上线"><a href="#小程序测速功能上线" class="headerlink" title="小程序测速功能上线"></a>小程序测速功能上线</h3><p>“小程序测速”功能可以简单方便地统计小程序内某一事件的实时耗时情况，并可根据地域、运营商、操作系统、网络类型、机型等关键维度进行交叉分析。对于更复杂的用户场景，还可以使用自定义维度进行分析。从基础库2.9.2开始，开发者通过“测速上报”接口上报某一指标的耗时情况后，可在小程序管理后台”开发 -运维中心 -小程序测速” 查看各指标耗时趋势，并支持分钟级数据实时查看。</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performanceReport/" target="_blank" rel="external">《小程序测速》使用指南</a></li></ul><h2 id="小程序·云开发"><a href="#小程序·云开发" class="headerlink" title="小程序·云开发"></a>小程序·云开发</h2><blockquote><p>暂无更新</p></blockquote><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><h3 id="代码编译和上传-CI-模块"><a href="#代码编译和上传-CI-模块" class="headerlink" title="代码编译和上传 CI 模块"></a>代码编译和上传 CI 模块</h3><blockquote><p>该部分内容上期更新补充过，但官方更新时间属于本期，因此再发一次。</p></blockquote><p>为助力开发者进行小程序开发的自动化，实现功能的持续集成，小程序团队抽离了开发者工具中的代码编译以及上传能力，新增 <a href="https://www.npmjs.com/package/miniprogram-ci" target="_blank" rel="external">miniprogram-ci</a> 模块。该模块可以极大地方便开发者将小程序代码上传和预览操作同已有系统相结合。<br>miniprogram-ci 是从微信开发者工具中抽离的关于小程序/小游戏项目代码的编译模块，目前提供以下能力：</p><ol><li>上传代码，对应小程序开发者工具的上传</li><li>预览代码，对应小程序开发者工具的预览</li><li>构建 npm，对应小程序开发者工具的: 菜单-工具-构建npm</li><li>代理，配置 miniprogram-ci 的网络请求代理方式</li><li>支持 node 脚本调用方式和 命令行 调用方式<br>使用 miniprogram-ci 模块前需要在微信公众平台-开发-开发设置中下载对应的代码上传密钥和配置 IP 白名单。</li></ol><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html" target="_blank" rel="external">参考文档地址</a></li></ul><p>更多的内容可以查看：</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html" target="_blank" rel="external">稳定版 Stable Build 更新日志</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">开发版 Nightly Build 更新日志</a></li></ul><h1 id="小程序教程"><a href="#小程序教程" class="headerlink" title="小程序教程"></a>小程序教程</h1><h2 id="社区精选文章"><a href="#社区精选文章" class="headerlink" title="社区精选文章"></a>社区精选文章</h2><ul><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000224ac24882059eb2a0775f51013" target="_blank" rel="external">网页端管理系统在小程序上的实现</a></li></ul><p>往期内容可以查看<a href="https://developers.weixin.qq.com/community/develop/article" target="_blank" rel="external">文章分享</a></p><blockquote><p>最近社区的精选文章都木有怎么更新来着。</p></blockquote><h2 id="最新踩坑-amp-amp-Tips"><a href="#最新踩坑-amp-amp-Tips" class="headerlink" title="最新踩坑 &amp;&amp; Tips"></a>最新踩坑 &amp;&amp; Tips</h2><h3 id="iOS-下Promise-finally-异常"><a href="#iOS-下Promise-finally-异常" class="headerlink" title="iOS 下Promise.finally()异常"></a>iOS 下<code>Promise.finally()</code>异常</h3><p><code>Promise.finally()</code>在iOS下会出现故障，安卓下表现良好，若使用需要注意。</p><ul><li><a href="https://developers.weixin.qq.com/community/develop/doc/000caaefe54f70567a4933aaa56000" target="_blank" rel="external">参考</a></li></ul><h3 id="wx-chooseContact-拉起通信录接口异常"><a href="#wx-chooseContact-拉起通信录接口异常" class="headerlink" title="wx.chooseContact()拉起通信录接口异常"></a><code>wx.chooseContact()</code>拉起通信录接口异常</h3><p>小程序中调用过<code>wx.chooseContact()</code> api后，再调用其他 api 都会失败。</p><ul><li>出现异常版本：iOS 13.3.1 + 微信 7.0.12</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本期木有结束语，祝各位的大头菜都涨涨涨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又一个月过去了，大家也快习惯了带着口罩上班，饭堂也在慢慢恢复菜单供打包，捡树枝活动异常火热，我们来看看小程序又更新了哪些能力吧~&lt;br&gt;
    
    </summary>
    
      <category term="小程序双皮奶" scheme="https://godbasin.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8C%E7%9A%AE%E5%A5%B6/"/>
    
    
      <category term="教程" scheme="https://godbasin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--7.情绪与保持清醒</title>
    <link href="https://godbasin.github.io/2020/04/05/about-front-end-7/"/>
    <id>https://godbasin.github.io/2020/04/05/about-front-end-7/</id>
    <published>2020-04-05T06:12:05.000Z</published>
    <updated>2020-04-05T11:05:24.674Z</updated>
    
    <content type="html"><![CDATA[<p>工作中我们总会遇到各种意料之外的事情，但不管是高兴、激动的时候，还是难过、低落甚至愤怒的时候，我们都需要保持清醒。</p><a id="more"></a><h1 id="工作中的各种情绪"><a href="#工作中的各种情绪" class="headerlink" title="工作中的各种情绪"></a>工作中的各种情绪</h1><hr><p>相信每个人的工作里，都遇到过各种各样的事情，有完成某个挑战的激动、涨工资的喜悦，也有接手坑多代码的吐血、遇到不公正的气愤、不被重视的低落、不被理解的失望，等等。这些情绪会一直伴随着我们，要怎么和它们和谐相处呢？</p><h2 id="有情绪实在是太正常了"><a href="#有情绪实在是太正常了" class="headerlink" title="有情绪实在是太正常了"></a>有情绪实在是太正常了</h2><p>遇到问题的时候，我们总是无法保持冷静，但反观周围的人都似乎没什么反应，是我太激动了吗？会显得太幼稚吗？</p><p>并不是这样的。这些事情发生在自己身上的时候，有情绪几乎是大多数人的自然反应。现实中我们看到很多不动声色的人，多半是因为事不关己，有一些是过来人。工作是一个较理性的场合，在这里我们尽可能“讲道理”，让大家都体面，这是大部分人的共识。</p><p>当然，一个合格的职场人应该具备控制自己情绪的能力，也有很多人教我们“要做情绪的主人”。但是不是意味着有情绪就是不合适的呢？也不是的，相比暗地里较量，适当的情绪表达可以让事情变得简单。</p><p>之前看一本谈判课的书上讲到，谈判过程中有比双赢更重要的事情，那就是实现目标。因为我们并不是任何时候都需要双赢，有时候我们想“全盘皆输”，因为希望双方都能体会对方的心情。有时候我们想要“我赢你输”，要给对方一个教训。情绪表达也一样，社会中“欺软怕硬”的人也不少，有时候使用愤怒也可以表达出你并不是一个包子，可以一定程度上改善现有的困境。</p><p>正因为我们对这个世界有所期待，才会在遇到不公的时候如此愤慨。而在社会上经历过好些年的，能保持初心的就更少了。我们之所以有各式各样的情绪，除了跟外在的环境有关，也跟个人的经历有关，并没有对错之分，这只是跟我们吃饭睡觉一样正常的事情。</p><h2 id="要怎么调整呢"><a href="#要怎么调整呢" class="headerlink" title="要怎么调整呢"></a>要怎么调整呢</h2><p>为了避免情绪的失控，我们总归需要对其进行调整。每个人的情绪值都是不一样的，并不是说我要跟别人一样淡定才好，而是控制在适合自己的范围内就可以。</p><p>当然，随着经历越来越丰富，大多数人对情绪也会渐渐习惯或是麻木。像如今的你，虽然已经能接受很多以前觉得不合理的事情，但又有多少事情不再能让你展现笑容了呢？从这个角度看来，“慢慢就会适应”并不一定是一个好方法，保持对工作和生活的热情、保持好奇心，会让你的一生更加多姿多彩。</p><p>情绪的调整有很多种方式，常用的包括回避、转移注意力、改变认知、控制表情等等。</p><p>回避，可以理解为“逃避可耻但是有用”，我们远离触发情绪的情景、环境，这是小孩子都会做的事情，而有些时候的确也很有效，例如工作环境的转换或调整（换工作）、远离伤心地等。但如果引起我们情绪的因素太多，有时候躲得了初一躲不过十五，这并不算是一个很好的解决办法。</p><p>转移注意力，相信大多数人也会这么做。例如工作很多烦人的事情，下班后打盘dota就满血复活。又或者在业余时间健身、学画画、学做饭、学钢琴等等，培养一定的兴趣爱好可以让我们有效地转移注意力，不再沉浸在消极情绪中。</p><p>改变认知，也就是理解这些事情，学会接受。这是可以根本解决问题的方式，但实际上大多数人并不能真正释怀，这也很难做到。我们可以阶段性地进行调整，然后配合适当的回避、转移注意力等方法，来控制好自己的情绪。</p><p>控制表情。有研究表明，表情和动作在一定程度上也会增强我们的情绪，例如笑容会给人带来积极情绪。而表情的控制有时候也可以让我们达到目的，虽然内心波涛汹涌，但没有表露出来，对职场人来说有时候也是一种生存手段。</p><h2 id="调整不到怎么办"><a href="#调整不到怎么办" class="headerlink" title="调整不到怎么办"></a>调整不到怎么办</h2><p>是的，即使我们知道很多的技巧和方法来控制情绪，但并不是每次我们都可以控制住。</p><p>接受这样的自己吧，接受这个不完美的自己。将对自己的预期调整为偶尔会爆发，这样也可以在情绪失控之后更容易调整恢复，找回自我。我们都不是完人，都有缺点，情绪失控也不是什么大事情（当然前提是别犯罪），承认自己的不足才能更好地改变。</p><p>情绪失控后，请记得要收拾现场。我们情绪爆发的时候常常会伤害到身边的人，所以请记得说声抱歉，请喝个奶茶咖啡、吃顿饭等等各种方式都可以，但要表达出自己的歉意。有时候示弱并不会让我们看上去更弱，而可以让我们更真诚，真诚和信任才是人与人之间最重要的东西。</p><h1 id="不管怎样，保持清醒"><a href="#不管怎样，保持清醒" class="headerlink" title="不管怎样，保持清醒"></a>不管怎样，保持清醒</h1><hr><p>满心欢喜也好，饥不择食也好，前面<a href="">前端这几年–3.关于成长和焦虑</a>一文中我也有讲到过，在职场中时刻保持清醒很重要。</p><h2 id="防止情绪的积累"><a href="#防止情绪的积累" class="headerlink" title="防止情绪的积累"></a>防止情绪的积累</h2><p>情绪失控不可怕，情绪的积累其实影响更大。如果情绪得不到排解，它就会一次又一次地冲击，甚至越来越强烈，最终可能导致不可逆的一些结果。</p><p>我们都知道，要每时每刻保持情绪稳定是很难的，所以前面也说过可以适当地发泄。如果条件允许，我们可以选择合适的场地、合适的方式来进行发泄，例如有些人喜欢运动，出一身汗就可以调整情绪，有些人爱旅行，出去看看形形色色的事物就可以平复心情，有些人爱打游戏，在游戏里大赢一场就好了。</p><p>情绪的积累除了适当的发泄，平日里可以多和人聊聊天、吐吐槽也是可以的。当然，如果对方是同事，这种情况下通常会被组织者认为是负能量的传播。但情绪依然需要一个出口，负能量如果是组织带来的，组织也应当提供一个合适的消耗方式。还是那句话，正是因为有所期待才会有失望，只有正视问题才可以得到解决。</p><p>很多人也喜欢用比惨的方式来相互调侃，得到慰藉。除了吐槽，我们还可以多往未来看去。很多时候我们情绪无法调整，多是因为沉浸于其中无法自拔。即使是一些“中了一千万彩票要怎么花”、“今年要去哪旅行”、“辞职以后要做什么”，甚至是“这个周末要吃点什么”、“最近有什么好看的电影、好玩的游戏”这些比较简单的讨论都可以很好地转移注意力。</p><p>活了这么久，相信你们也总有那么一两个可以吐露心声的朋友，难过的时候如果无法自己调整，请记得要寻找帮助噢。每个人都有困难的时候，这并不是什么说不出口的事情呢。</p><h2 id="请时刻保持清醒"><a href="#请时刻保持清醒" class="headerlink" title="请时刻保持清醒"></a>请时刻保持清醒</h2><p>你们是不是觉得，既然无法时刻控制好情绪，那怎么可能时刻保持清醒呢？这里的保持清醒，是说即使是很愤怒、很难过的时候，也依然不要让情绪去做决定。</p><p>这些年来，越是处于情绪中，越能想清楚要怎么走，心底里会有个声音呼喊“这样下去不行”。即使我情绪爆发了、失控了，但平静下来之后，这些遇到的事情都只会让我更坚定自己的一些决心。事不过三，伤心、失望、难过之后，我会给自己计数，同样的事情不会让它一直发生下去。而至今为止，我也很庆幸自己能在这些时候冷静思考，虽然弯路少不了，但至少没有走歪。</p><p>我们经常会做错事情，也做过许多有遗憾的决定，但在一些人生中比较重要的十字路口，我依然希望你们可以看清自己，理性也好、感性也好，清醒地作出这个决定。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>情绪控制我也在努力学习，希望能减少带给身边亲人朋友的负担。但我依然希望自己保留一股热血，敢爱敢恨地和这个世界谈一场恋爱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中我们总会遇到各种意料之外的事情，但不管是高兴、激动的时候，还是难过、低落甚至愤怒的时候，我们都需要保持清醒。&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>前端面试这件事--5.其他内容概述</title>
    <link href="https://godbasin.github.io/2020/04/04/interview-5-other-skills/"/>
    <id>https://godbasin.github.io/2020/04/04/interview-5-other-skills/</id>
    <published>2020-04-04T12:15:31.000Z</published>
    <updated>2020-04-05T11:03:31.096Z</updated>
    
    <content type="html"><![CDATA[<p>这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文概括地描述一下，面试中除了专业知识和项目相关，还可能会问到的一些问题。<br><a id="more"></a></p><p>专业知识也好，项目经验也好，比较难体现日常工作中的一些能力。而通过一些其他的问题，面试官可以更加全面地掌握面试者的信息。</p><h2 id="逻辑思维"><a href="#逻辑思维" class="headerlink" title="逻辑思维"></a>逻辑思维</h2><p>逻辑思维主要考察面试者思考的能力，是否结构化、是否有条理，表达描述是否清晰等。</p><h3 id="技术开放题"><a href="#技术开放题" class="headerlink" title="技术开放题"></a>技术开放题</h3><p>使用技术相关的开放题，既可以考察面试对象对技术的掌握和灵活使用的程度。可能会包括以下的问题（内容来自<a href="https://github.com/airuikun/Weekly-FE-Interview" target="_blank" rel="external">Weekly-FE-Interview</a>）：</p><ul><li>一次性插入 1000 个 div，如何优化插入的性能</li><li>内存不足，一次只允许你装载和操作 1 亿条数据，如何对 100 亿条数据进行排序</li><li>在浏览器端，用 JS 存储 2 万个小球的信息，包含小球的大小，位置，颜色等，如何做到对这2万条小球信息进行最优检索和存储</li></ul><h3 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h3><p>设计方案的方式，比较贴近工作过程，可以从多个角度考察面试者的知识面、问题瓶颈和边界情况的考虑。通常可能包括以下的内容：</p><ul><li>现在要做一个坦克对战的游戏，由你来设计，需要考虑哪些问题</li><li>如果让你做一个俄罗斯方块的游戏，讲讲具体的思路</li><li>做春节红包、秒杀活动中需要注意什么问题</li><li>现在需要通过配置的方式生成各种各样的 H5 活动页面，如何实现</li></ul><h3 id="逻辑思考"><a href="#逻辑思考" class="headerlink" title="逻辑思考"></a>逻辑思考</h3><p>除了方案设计，一些逻辑推导的题目也可以作为考察的一部分。通常来说这类题目有时候让人觉得像脑筋急转弯，可能是这样的题目（有些从网上扒来的题目）：</p><ul><li>一个 5L、一个 6L 的瓶子，要得到 3L 的水，要怎么做</li><li>在一天之中，时针和分针共重叠多少次，时间分别是多少</li><li>1=5，2=15，3=215，4=2145，那么 5=?</li><li>现有 64 匹马，8 赛道，至少跑多少个回合可以得到前 4 名</li></ul><p>还有一些开放性的题目，包括：</p><ul><li>为什么下水道的盖子是圆的</li><li>一个是两种药片，每种有两个，一个人需要早上吃两种药片各一个，现在这四个药片混在一起了这个人什么方法吃</li><li>请把一盒蛋糕切成8份，分给8个人，但蛋糕盒里还必须留有一份</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了项目内容，面试官有时候也会了解面试者的一些工作以外的情况。</p><h3 id="学习与技能"><a href="#学习与技能" class="headerlink" title="学习与技能"></a>学习与技能</h3><p>对于程序员来说，自学是很关键的一个能力，而面试过程可能会问到：</p><ul><li>平时业余时间有进行学习吗，学习方式是怎样的</li><li>会通过哪些途径来了解最新的前端技术</li><li>最近有看哪些书，描述一下相关内容</li><li>近一年有关注过什么新技术，简单介绍一下</li><li>这一年中做过最有挑战性的工作是什么，过程是怎样的</li><li>技术领域中最喜欢的东西是什么、为什么</li><li>日常工作有难度吗，难点在哪</li><li>你最喜欢的前端项目是什么、为什么</li><li>个人的职业规划是如何的</li></ul><h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><ul><li>自己最擅长的是什么工作</li><li>你在这个项目中的角色是是什么</li><li>你觉得自己给团队带来了哪些价值、做了什么贡献</li><li>对新的团队有没有什么要求</li><li>团队合作中的代码可读性和维护性，你怎么看</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文更多的介绍一些补充的内容，这些内容会因为面试官的喜好而不一样，所以运气也是面试过程中的一个因素，也可以理解为你和这个团队有没有缘分吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文概括地描述一下，面试中除了专业知识和项目相关，还可能会问到的一些问题。&lt;br&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--6.工作选择的困惑</title>
    <link href="https://godbasin.github.io/2020/03/29/about-front-end-6/"/>
    <id>https://godbasin.github.io/2020/03/29/about-front-end-6/</id>
    <published>2020-03-29T06:10:52.000Z</published>
    <updated>2020-03-29T14:24:09.613Z</updated>
    
    <content type="html"><![CDATA[<p>工作有好几年了，也常常看到身边的同事朋友在工作过程中有不少关于选择的困惑。通常包括该不该跳槽、要不要改变自己一些，还有使得自己每日上班如上坟的各种事情。那么，我该不该换个工作呢？</p><a id="more"></a><h1 id="什么时候该说再见"><a href="#什么时候该说再见" class="headerlink" title="什么时候该说再见"></a>什么时候该说再见</h1><p>问题来了，我们什么时候该告别现在的工作，踏上新的征途呢？</p><h2 id="找准自身定位"><a href="#找准自身定位" class="headerlink" title="找准自身定位"></a>找准自身定位</h2><p>我以前常常换工作，看起来毫无章法，其实内心有比较清晰的方向，关于最终要去哪，是否可以一步到位，中间要怎么调整才可以到达目的地。这些问题，都常常在想。</p><p>不少小伙伴找工作容易陷入误区，常常因为“别人赚钱比我多”而愤愤不平，然后越想越不爽，就也开始准备面试找工作了。但其实时间久了你会发现，身边过得比自己好的人多如牛毛，如果每一次都无法忍受的话，自己的生活就被掌握在别人手中啦。</p><p>我们要做的，是找准自己的定位。</p><p>找准当前的工作在职业规划中的定位。我们每次找工作，其实都有一定的预期，那么手上这份工作也是。例如，我一直在做管理端/增删改查，我想接触些量大的业务。那么你当前工作中，你是依然简单地完成功能开发，还是有学习和实践业务量大的情况下，前端要考虑哪些问题、做哪些风险应对、如何做服务降级、页面性能优化怎么做、首屏直出又有多少种方案。</p><p>你来这里的目的都完成了吗？如果没有，还有希望完成吗？要怎么才能完成？如果完成了、或者条件限制你没法完成，的确可以考虑是否做下调整。</p><p>找准自身在当前团队中的定位。每个人在团队中都有不同的定位，例如有些人比较擅长解决线上问题，有些人擅长做架构设计，有些人没啥喜欢的只想着按时下班。而团队的氛围也跟管理者有很大的关系，有些管理者希望每个人都能独挡一面，有些觉得大家各司其职，有的喜欢和大家一起讨论，有的喜欢把所有事情都控制在自己手里。</p><p>而你自身的优势是什么？当前团队中有可以发挥的地方吗？举个例子，我喜欢分享讨论、自身在思考和沉淀方面也有较多的经验，如果团队对我的期望就是“只需要做我给你讲的，按照我讲的方式去做”，而当我提出其他方案的时候被打击了，那我可以从这样的团队中发挥自己最擅长的能力吗？</p><p>工作中更有效的方式是扬长避短，而不是花很多时间去补齐短板。如果你的长处没有发挥出来，是否可以自我调整或找管理者协调调整呢？如果没法调整，是不是可以考虑调整工作呢？</p><h2 id="可接受的调整范围"><a href="#可接受的调整范围" class="headerlink" title="可接受的调整范围"></a>可接受的调整范围</h2><p>我们换工作，除了让人颠倒三观的奇葩人和事，一般都是因为几个原因：缺乏成长、没钱、加班太疯狂、管理问题等。那么，我们不可接受的内容，是还有调整的余地呢？还是已经触碰到自己的底线呢？</p><p>我们每个人都有一些称之为“底线”的原则，在<a href="">前端这几年–2.工作原则和选择</a>一文中其实也有详细地讲述了我的一些观点。而工作和生活一样常常并不会如你所愿，即使我们定下来一些认为不可撼动的原则，却也辗转之后发现“这个世界就是这样子的啦”。会自我怀疑，自我否定，最终容易丢失了自己。</p><p>遇到这样的问题怎么办？你可以先调整下情绪，静下心来分析一下，当前这个工作能给你带来什么？又会让你失去什么呢？如果你能收获的东西，价值远大于你会失去的，则不妨考虑一下“忍一时风平浪静”，先把需要的经验、金钱、成长值到手，再考虑跟现在的工作说再见。很多时候，一些让人难受的经历，其实也会让人成长，虽然未必是你希望的方式。</p><p>如果你能收获的比不上你会失去的，那就“退一步海阔天空，你退我不退”。好好准备一下面试，找一份可以让你有一定增值的工作吧。</p><h2 id="成长-or-赚钱？"><a href="#成长-or-赚钱？" class="headerlink" title="成长 or 赚钱？"></a>成长 or 赚钱？</h2><p>一份好的工作，通常是既可以让你获得成长，也可以有不错的待遇。但现状是，这样的好工作你想要，我也想要，当然是有能力的人占有更多的机会。</p><p>所以我们常常说的“所有工作都是这样子的啦”，这句话并不全对。我们之所以遇到这样的工作，是因为能力不足。在职业发展的前面很长一个阶段，成长都比赚钱重要，因为只有不断成长，你才可能在未来的某一天找到一份又喜欢又赚钱的工作。</p><p>成长，除了专业技能的成长，也包括一系列工作素养、工作方法、经验积累和个人影响力等。越是往后面的路走，后者的一些重要性也会慢慢显现，所以在做职业规划的时候也可以考虑进去。</p><p>但其实对更多的人来说，工作只是养家糊口的一种手段。赚钱就是最终的目的，也没有对职业规划的执着，想着趁年轻赚点钱以后财富自由，那么对于他们来说，可以考虑下适当时候选择赚钱而不是成长的工作。但有一点需要注意的是，如果获得的成长值不够，很可能在财富自由之前就失去了这个机会了。</p><h1 id="say-goodbye"><a href="#say-goodbye" class="headerlink" title="say goodbye"></a>say goodbye</h1><p>如果以上内容都分析考虑清楚，依然决定要离开，那么就走吧~走吧~</p><h2 id="坚决但留有余地"><a href="#坚决但留有余地" class="headerlink" title="坚决但留有余地"></a>坚决但留有余地</h2><p>一般来说，当我们提离职之后，通常首先会收到上级的挽留。以前不听你建议的，可能这个时候就开始想要听听你的想法。当然这种上级还是不多，更多的情况下，你的困境他未必可以帮你解决，例如钱不够（差很远）、工作内容不适合、没有成长和挑战性等。可能你遇到的问题他也同样在烦恼，甚至他也在默默看机会中。</p><p>如果你开始提离职了，最好的结果是你走了。除非你特别牛逼，不然留下来之后位置会比较被动。所以，在提离职以前，如果是有商量余地，尽量主动先找上级讨论一下。我一直觉得领导和组员之间比较好的关系是“相互利用”，我替你解决问题，你帮我解决资源。如果无法达成一致，才来提离职会更好。</p><p>留有余地要怎么理解，其实可以跟下面的内容一起来讲。</p><h2 id="好聚好散"><a href="#好聚好散" class="headerlink" title="好聚好散"></a>好聚好散</h2><p>我不怎么擅长好聚好散，大概是因为运气比较糟糕遇到一些不咋地的老板，又或者是我一般都会提前争取、沟通失败才提出离开，这种情况下常常也较失望了。</p><p>以前遇到的好几次没有好聚好散的，包括老板不肯给我涨薪、然后提离职之后又说要涨一点但达不到我的预期，坚持要走他就开始破口大骂，甚至威胁这行业就这么大我走不到哪去。还有一次是刚换工作大概一个月，中间身体原因请过几次假去看病，后来收到入院通知，领导知道了在那一边骂“女生就是矫情”、一边把我清理出公司的各种群，工资也不发直接线上解雇，而我由于身体原因也无法及时上门算账。这么想来，其实也不是我不擅长好聚好散，而终究是遇人不淑。</p><p>不管怎样，这一路上我遇到了很多很棒的小伙伴，也有很多现在依然保持联系，毕竟这行业也就这么大，以后说不定还有合作的机会。在商汤的时候，我就有一个很好的部门领导，到现在我依然有想法“说不定以后还有机会跟他一起工作”。</p><p>好聚好散真的很重要，大家都需要体面地活着，留一步退路可以让你的路有更多的选择。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>林子大了什么鸟都有，当你进入社会之后，这句话越发显得真实。这句话可能稍微带点贬义，但却比其他语句更能表达这些年的经历。所以遇到再大的事情，你都要知道它都会慢慢变成小事，最终成为往事。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作有好几年了，也常常看到身边的同事朋友在工作过程中有不少关于选择的困惑。通常包括该不该跳槽、要不要改变自己一些，还有使得自己每日上班如上坟的各种事情。那么，我该不该换个工作呢？&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>前端面试这件事--4.项目经验概述</title>
    <link href="https://godbasin.github.io/2020/03/28/interview-4-project-skills/"/>
    <id>https://godbasin.github.io/2020/03/28/interview-4-project-skills/</id>
    <published>2020-03-28T12:55:31.000Z</published>
    <updated>2020-03-29T14:25:09.740Z</updated>
    
    <content type="html"><![CDATA[<p>这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文概括地描述一下，面试过程中前端项目经验相关的问题。<br><a id="more"></a></p><p>上一篇我们介绍了前端面试中常见的一些基础专业知识，这些是面试的门槛。那要如何考察面试者的能力呢，通常会从对方的简历下手，询问相关的项目经验。</p><h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><p>项目经验通常和个人经历关系比较大，前端业务相关的的一些项目经验通常包括管理端、H5直出、Node.js、可视化，另外还包括参与工具开发的经验，方案选型、架构设计等。</p><h3 id="前端框架与工具库"><a href="#前端框架与工具库" class="headerlink" title="前端框架与工具库"></a>前端框架与工具库</h3><p>首先我们来看看前端框架，不管你开发管理端、PC Web、H5，还是现在比较流行的小程序，总会面临要使用某一个框架来开发。因此，以下的问题可能与你有关：</p><ul><li>谈谈你对前端常见的框架（Angular/React/Vue）的理解</li><li>该项目使用 Angular/React/Vue 的原因是</li><li>如果现在你重新决策，你会使用什么框架</li><li>你有了解过这些框架都做了哪些事情，介绍一下是怎么实现的</li><li>Vue 中的双向绑定是怎么实现的？</li><li>介绍下 Angular 中的依赖注入</li><li>讲讲 React 的虚拟 DOM</li><li>如何进行状态管理，Vuex/Redux/Mobx 等工具是怎么做的</li><li>单页应用是什么？路由是如何实现的</li><li>如何进行 SEO 优化</li></ul><p>如果你使用到了小程序，还可能会问到：</p><ul><li>小程序和 H5 有什么不一样，为什么选小程序而不是 H5</li><li>有考虑在小程序里嵌 H5 实现吗，为什么</li><li>为什么小程序的性能要好一些</li><li>小程序开发有用到哪些框架吗、为什么</li></ul><p>而工具库相关的就太多啦，一般会这么问：</p><ul><li>有实际使用过哪些第三方库</li><li>这些工具库有什么特性和优缺点</li></ul><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>Node.js 相关的可能包括：</p><ul><li>为什么要用 Node.js（而不是 PHP/JAVA/GO/C++ 等）</li><li>Node.js 有哪些特点，单线程的优势和缺点是什么</li><li>Node.js 有哪些定时功能</li><li>Process.nextTick 和 setImmediate 的区别</li><li>Node.js 中的异步和同步怎么理解，异步流程如何控制</li><li>简单介绍一下 Node.js 中的核心内置类库(事件，流，文件，网络等)</li><li>express 是如何从一个中间件执行到下一个中间件的</li><li>express、koa、egg 之间的区别</li><li>Rest API 有使用过吗，介绍一下</li></ul><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>如今前端工程化的趋势越来越重，通常从脚手架开始：</p><ul><li>为什么我们开发的时候要使用脚手架</li><li>如何理解模块化</li><li>为什么要使用 Webpack，它和 Gulp 的区别是</li><li>讲一下 Webpack 中常用的一些配置、Loader、插件</li><li>Babel 的作用是什么，如何选择合适的 Babel 版本</li><li>Webpack 是怎么将多个文件打包成一个，依赖问题如何解决</li><li>CSS 文件打包过程中，如何避免 CSS 全局污染</li><li>本地开发和代码打包的流程分别是怎样的</li></ul><p>除了脚手架相关，如今自动化、流程化的使用也越来越多了：</p><ul><li>你们的项目有使用 CI/CD 吗，为什么</li><li>你们的代码有写单元测试/自动化测试吗，为什么</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>性能优化的其实跟项目比较相关，常见的包括：</p><ul><li>常见的性能优化包括哪些内容</li><li>如何理解性能瓶颈</li><li>图片加载性能有哪些可以优化的地方</li><li>要怎么做好代码分割</li><li>首屏页面加载很慢，要怎么优化</li><li>Tree Shaking 是怎样一个过程</li><li>页面有没有做什么柔性降级的处理</li></ul><h3 id="效能提升"><a href="#效能提升" class="headerlink" title="效能提升"></a>效能提升</h3><p>效能提升的意识在工作中很重要，大家都不喜欢低效的加班。通常可能问到的问题包括：</p><ul><li>做了很多的管理端/H5，有考虑过怎么提升开发效率吗</li><li>你的项目里，有没有哪些工作是可以用工具完成的</li><li>项目中有进行组件和公共库的封装吗</li><li>如何管理这些公共组件/工具的兼容问题</li><li>日常工作中，如何提升自己的工作效率</li></ul><h3 id="监控与灰度发布"><a href="#监控与灰度发布" class="headerlink" title="监控与灰度发布"></a>监控与灰度发布</h3><p>发布和监控这部分，可能较大的业务才会有，涉及的问题可以有:</p><ul><li>日常开发过程中，怎么保证页面质量</li><li>版本发布有进行灰度吗？灰度的过程是怎样的</li><li>版本发布过程中，如何及时地发现问题</li><li>发生异常，要怎么快速地定位到具体位置</li><li>如何观察线上代码的运行质量</li></ul><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>一些较大的项目，通常由多个开发合作完成。而多人协作的经验也很有帮助：</p><ul><li>多人开发过程中，代码冲突如何解决</li><li>介绍一下 git flow 流程</li><li>如果项目频繁交接，如果提升开发效率</li><li>有遇到代码习惯差异的问题吗，如何解决</li><li>有哪些常用的代码校验的工具</li><li>怎么强制进行 Code Review</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>看到这么多内容不要慌，一般来说面试官只会根据你的工作经历来询问对应的问题，所以如果你并没有完全掌握某一块的内容，请不要写在简历上，你永远也不知道面试官会延伸到哪。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文概括地描述一下，面试过程中前端项目经验相关的问题。&lt;br&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>前端面试这件事--3.专业知识概述</title>
    <link href="https://godbasin.github.io/2020/03/21/interview-3-basic-skills/"/>
    <id>https://godbasin.github.io/2020/03/21/interview-3-basic-skills/</id>
    <published>2020-03-21T01:40:45.000Z</published>
    <updated>2020-03-22T02:50:16.645Z</updated>
    
    <content type="html"><![CDATA[<p>这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文概括地描述一下，面试中可能会遇到的一些基础专业知识。<br><a id="more"></a></p><p>在进行面试前复习的时候，我们需要有结构、有逻辑地进行知识的梳理，那么大概有哪些知识点需要准备呢？面试官又可能会问到哪些内容呢？</p><h2 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h2><p>这里会针对前端小伙伴来进行相关专业知识的准备说明，本文只做范围的概述，后面再有详细的文章来一个个讲解。</p><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><p>前端最基础的技能包括 Javascript、CSS 和 HTML，新手比较容易遇到这方面的考察。对于Javascript会问到多一些，通常包括：</p><table><thead><tr><th>考察范围</th><th>具体问题</th></tr></thead><tbody><tr><td>对单线程 Javascript 的理解</td><td>单线程来源<br>Web Workers 和 Service Workers 的理解</td></tr><tr><td>异步事件机制</td><td>为什么使用异步事件机制<br>在实际使用中异步事件可能会导致什么问题<br>关于 setTimeout、setInterval 的时间精确性</td></tr><tr><td>对 EventLoop 的理解</td><td>介绍浏览器的 EventLoop<br>macrotask 和 microtask 的区别<br>setTimeout 和 Promise 在不同浏览器的执行顺序</td></tr><tr><td>Javascript 的原型和继承</td><td>如何理解 Javascript 中的“一切皆对象”<br>如何创建一个对象<br>proto 与 prototype 的区别</td></tr><tr><td>作用域与闭包</td><td>请描述以下代码的执行输出内容（考察作用域）<br>什么场景需要使用闭包<br>闭包的缺陷</td></tr><tr><td>this</td><td>简单描述 this 在不同场景下的指向<br>apply 和 call 的使用<br>箭头函数与普通函数的区别</td></tr><tr><td>ES6+</td><td>对 Promise 的理解<br>使用 async、await 的好处<br>浏览器兼容性与 Babel<br>Set 和 Map 数据结构</td></tr></tbody></table><p>对 Javascript 的考察，也可以通过写代码的方式来进行，例如：</p><ul><li>手写代码实现 call/apply/bind</li><li>手写代码实现 Promise、async/await</li><li>Javascript 中 0.1+0.2 为什么等于 0.30000000000000004，如何通过代码解决这个问题</li></ul><h3 id="HTML与CSS"><a href="#HTML与CSS" class="headerlink" title="HTML与CSS"></a>HTML与CSS</h3><p>关于 HTML 的内容会较少单独地问，更多是结合浏览器的渲染机制等一起考察。关于 CSS，也有以下的一些考察点：</p><ul><li>介绍盒子模型</li><li>内联元素与块状元素、display</li><li>文档流的理解：static/relative/absolute/fixed等</li><li>元素堆叠：z-index 与 position 的作用关系</li><li>Flex 布局方式的理解和使用</li><li>BFC 的优点和缺点</li><li>CSS 动画考察：关键帧、animate、transition 等</li></ul><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p>网络相关的知识在日常开发中也是挺常用的，相关的问题可以从“一个完整的HTTP请求过程”来讲述，包括：</p><ul><li>域名解析（此处涉及 DNS 的寻址过程）</li><li>TCP 的 3 次握手</li><li>建立 TCP 连接后发起 HTTP 请求</li><li>服务器响应 HTTP 请求</li></ul><p>以上的内容都需要尽数掌握，除此以外，关于 HTTP 的还有以下常见内容：</p><ul><li>HTTP 消息的结构，包括 Request请求、Response响应</li><li>HTTP 请求方法，使用 PUT、DELETE 等方法时为什么有时候在浏览器会看到两次请求（涉及 CROS 中的简单请求和复杂请求）</li><li>常见的 HTTP 状态码</li><li>浏览器是如何控制缓存的：相应的头信息、状态码</li><li>如何对请求进行抓包和改造</li><li>Websocket 与 HTTP 请求的区别</li><li>HTTPS、HTTP2 与 HTTP 的对比</li></ul><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><p>关于浏览器，有很多的机制需要掌握。通常来说，面试官会从一个叫“在浏览器里面输入url，按下 enter 键，会发生什么？”中进行考察，首先会经过上面提到的 HTTP 请求过程，然后还会涉及以下内容：</p><table><thead><tr><th>考察内容</th><th>相关问题</th></tr></thead><tbody><tr><td>浏览器的同源策略</td><td>“同源”指什么<br>那些行为受到同源策略的限制<br>常见的跨域方案有哪些</td></tr><tr><td>浏览器的缓存相关</td><td>Web 缓存通常包括哪些<br>浏览器什么情况下会使用本地缓存<br>强缓存和协商缓存的区别<br>强制 ctrl + F5 刷新会发生什么<br>session、cookie 以及 storage 的区别</td></tr><tr><td>浏览器加载顺序</td><td>为什么我们通常将 javascript 放在 <code>&lt;body&gt;</code> 的最后面<br>为什么我们将 CSS 放在 <code>&lt;head&gt;</code> 里</td></tr><tr><td>浏览器的渲染原理</td><td>HTML/CSS/JS 的解析过程<br>Render Tree 是怎样生成的<br>Repaint 和 Reflow 是怎样的过程<br>日常开发中要注意哪些渲染性能问题<br></td></tr><tr><td>虚拟 DOM 机制</td><td>为什么要使用虚拟 DOM<br>为什么要使用 JS 对象来描述 DOM 结构<br>简单描述下虚拟 DOM 的实现原理</td></tr><tr><td>浏览器事件</td><td>DOM 事件流包括几个阶段（点击后会发生什么）<br>事件委托是什么</td></tr></tbody></table><h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><p>安全在实际开发中是最重要的，作为前端开发，同样需要掌握：</p><ul><li>前端安全中，需要注意的有哪些问题</li><li>XSS/CSRF 是怎样的攻击过程，要怎么防范</li><li>除了 XSS 和 CSRF，你还了解哪些网络安全相关的问题呢</li><li>SQL 注入、命令行注入是怎样进行的</li><li>DDoS 攻击是什么</li><li>流量劫持包括哪些内容</li></ul><h3 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h3><p>很多大公司会考察算法基础，大家其实也可以多上 leetcode 去刷题，这些题目刷多了就有感觉了。前端比较爱考的包括：</p><ul><li>各种排序算法、稳定排序与原地排序、JS 中的 sort 使用的是什么排序</li><li>查找算法（顺序、二分查找）</li><li>递归、分治的理解和应用</li><li>动态规划</li></ul><p>除此之外，常见的数据结构也需要掌握：</p><ul><li>链表与数组</li><li>栈与队列</li><li>二叉树、平衡树、红黑树等</li></ul><h3 id="计算机通用知识"><a href="#计算机通用知识" class="headerlink" title="计算机通用知识"></a>计算机通用知识</h3><p>虽然在日常工作中我们接触到的内容比较局限于前端开发，但以下内容如果能掌握，对个人成长和面试过程也会有所帮助：</p><ul><li>理解计算机资源，认识进程与线程（单线程、单进程、多线程、多进程）</li><li>了解阻塞与非阻塞、同步与异步任务等</li><li>进程间通信（IPC）常包括哪些方式，进程间同步机制又包括哪些方式</li><li>Socket与网络进程通信是怎样的关系、Socket连接过程是怎样的</li><li>简单了解数据库（事务、索引）</li><li>常见的设计模式有哪些、列举实际使用过的一些设计模式</li><li>如何理解面向对象编程、对函数式编程的看法</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>基础知识相关的内容真的不少呢，但是这块其实只要准备足够充分就可以掌握。参加过高考的我们，理解和记忆这么些内容，其实没有想象中那么难的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文概括地描述一下，面试中可能会遇到的一些基础专业知识。&lt;br&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>前端面试这件事--2.面试流程</title>
    <link href="https://godbasin.github.io/2020/03/15/interview-2-stage/"/>
    <id>https://godbasin.github.io/2020/03/15/interview-2-stage/</id>
    <published>2020-03-15T06:42:18.000Z</published>
    <updated>2020-03-15T06:47:21.929Z</updated>
    
    <content type="html"><![CDATA[<p>这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文介绍常见的面试流程，以及相关的一些技巧。<br><a id="more"></a></p><p>如果你也有过找工作经验，想必对一些面试的流程也稍有掌握。本文分享本骚年这些年来面试别人和被人面试的一些面试流程情况，帮助大家面试过程做好更多的准备。</p><h1 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h1><hr><h3 id="电话面试"><a href="#电话面试" class="headerlink" title="电话面试"></a>电话面试</h3><p>为了提升面试官和面试者的效率，节省相互间的时间和精力成本，通常前面 1-2 轮的基础技术面试会采用电话面试的方式。电话面试由于空间原因，面试官和面试者无法直接观察到对方，因此对面试者的表达能力要求更高。</p><p>很多人在电话面试的时候会稍微做点准备，例如准备一些资料在手边，又或者打开电脑浏览器随时准备搜索。这种方式比较适合有较完整准备的人，较完整准备的意思不是指把所有的面试题目和知识点都收集齐，而是指将这些资料都完全理解并二次整理的人。</p><p>在面试过程中，其实不建议使用查资料然后念出来这样的方式。作为面试官的时候，也经常会遇到一些小伙子在问到一些问题的时候，说“我看看”、“我想想”，然后过了差不多八九秒才开始描述，而描述的时候让人觉得在死记硬背。其实这样的方式会给面试官留下不好的印象，面试的过程除了考察对方的基础技能，也是寻找对方亮点、观察沟通能力和思维逻辑的一个过程，更多的时候由于基础技能只需要花时间就可以准备好，后者会更能让面试官产生产生一定的记忆。</p><p>电话面试过程中，面试官更容易由于对方的回答过于枯燥而失去耐心。所以如果你想要留下个好印象，尽量将要讲述的内容完全理解并进行二次加工，变成你自己的话语来输出吧。例如，讲到某个知识点的时候，可以结合自己的一些项目经验来辅助描述。</p><h3 id="视频面试"><a href="#视频面试" class="headerlink" title="视频面试"></a>视频面试</h3><p>视频面试在最近几年才开始兴起，目前还比较小众。视频面试相比于电话面试多了一些互动，能让面试官和面试者的氛围更加轻松。</p><p>更多的时候，视频面试会结合一些在线编程的平台来进行。面试官要求开发者通过实时的平台在线做题，面试官则可以观察到开发者的整个编码过程。除了平台以外，也可以通过面试者共享屏幕的方式来观察做题过程。</p><p>这种情况下，面试者最好准备一台平时用于开发的电脑，因为熟悉的编辑器或者较完备的环境都可以提升开发效率。而做题过程中，恰当地使用搜索引擎也是一种方式，毕竟日常工作里我们也经常需要搜索一些解决方案、不容易记住的语法或API等等。对于编程开发来说，如何高效地使用搜索引擎其实也是一个很重要的能力。面试官通常都不会要求不能搜索，但是直接搜题目答案就会稍微过分了点哈。</p><h3 id="现场面试"><a href="#现场面试" class="headerlink" title="现场面试"></a>现场面试</h3><p>虽然如今电话面试、视频面试等线上面试方式越来越普及，但大多数公司依然会保留现场面试的过程。</p><p>现场面试通常会将多次的面试都安排在一起，比较高效地完成一次面试。除了技术能力，工作中同样重要的一些能力，例如表达能力、逻辑思维、应变能力、抗压能力等，通过现场面试可以更全面地考察面试对象。所以，现场面试的时候，面试者如果表现得真诚、友好、自信、乐观、积极主动，会让面试官有更好的印象。</p><p>现场面试还可能会有笔试环节、问答环节等，网上也有很多的面经，大家也可以去找找看。</p><h2 id="常见的面试流程"><a href="#常见的面试流程" class="headerlink" title="常见的面试流程"></a>常见的面试流程</h2><hr><p>前面讲的是几种常见的面试方式，现在我们来看看常见的一些面试流程，也就是俗话中说的“一面”、“二面”、“最终面”等这些过程。</p><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>笔试题更多地出现在一些基础级别的岗位，通常用来考察基础能力。当你面试的岗位职级越来越高，笔试占有的比重会越来越轻，这个时候会更考察项目和思考的一些能力。</p><p>对于笔试环节，一般面试官提供一份笔试题，让对方在一定时间内完成，有条件的还会提供上机做题的方式。对于每天要面试很多人的面试官来说，这是一个比较高效的筛选方式。通过面试者的回答情况，以及简单地描述思考过程、相关的知识点，可以快速地考察一些基础能力是否扎实。</p><p>对于笔试题，有个痛点就是记不住常用的语法和API，于是很多笔试题都不限语言。实在记不住的时候，也是可以使用文字描述做题过程的，但如果能记住当然是更好的。</p><p>在这个环节中，刷题还是很重要的，多去网上搜一些相关的题目来练习吧。</p><h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><p>技术面试一般分为好几场，需要由2-3个相应的专业面试官多次考察，然后汇总得到一个综合的评价。该过程对于面试者的等级评定和最终定薪都有比较大的影响。</p><p>技术面除了考察基础技术，对于工作经验较少的面试者，也通常会加一些逻辑题来考察思维和逻辑。对于工作经验较多的面试者，则会更侧重地询问项目相关的内容，以及解决方案的输出。</p><p>如果你是应届生或者刚毕业没多久，可以侧重复习基础知识（刷题），以及提升思考方式和表达能力。同时如果有一定的相关项目经验、或是参与了一些开源项目、有自己的技术博客或是文章积累，也都是不错的亮点。</p><p>如果你工作两三年了或更多，需要更侧重关注自己的实践经验的积累、解决问题的方法、对项目的贡献等。不同于应届生是招来培养的，社招更多是招来干活和解决问题的，因此面试者需要让自己在思考、经验沉淀、解决方法等方面更加突出。面试官也通常会出一些“这个项目给到你，你要如何解决、你会如何考虑”等情况。</p><p>如果你面试的岗位中有管理团队（无论大小）的工作，会需要你能做出一些技术选型、对现有的一些技术有一定的了解，能做出合适的技术架构、对团队管理常见问题以及如何解决有一定的了解。</p><p>除此之外，面试官有时候也会问一些较灵活的题目，例如“你最近半年比较有挑战性的事情”、“你觉得自己的优势在哪里”、“你最擅长什么”等，来考察对方对项目和技术理解的深度。</p><h3 id="大佬面"><a href="#大佬面" class="headerlink" title="大佬面"></a>大佬面</h3><p>大佬面一般来说是由部门的管理者来进行，常常在HR面试前面，通常来说都是走个流程（当然也有例外）。</p><p>既然是走个流程，很多时候问的问题会根据大佬的心情而不一样。一般来说，你的简历里有让大佬感兴趣的部分，对方就会稍微问一下。如果没有比较特别的地方，可能也会简单地聊一下天就过了。</p><p>如果你走到了这个流程，可以放松自己来进行面试。</p><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><p>HR面试通常也是比较流程化，通常会问一些生活或者非专业相关的工作问题。</p><p>HR更多是在考察面试者的稳定性，常见的问题包括“为什么跳槽”、“结婚了没”、“有木有男/女朋友”、“是否异地恋”、“家在哪里”等。有些公司也会考察面试者的价值观，有的甚至还有一套价值观题目来做。其实也是从稳定性方面来把控，如果个人的价值观和公司文化不符合，其实也不适合长期合作。这个环节淘汰率也很低，毕竟招人不容易，但是如果没过也不用太纠结，勉强得到的工作常常会更让人折磨。</p><p>薪酬待遇的谈判也在这个环节，有些HR比较真诚，有的就喜欢砍价，这里得具体问题具体分析了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>一次面试过程算下来可能多的有七八轮，少的也有四五轮，找工作真是场持久战呢。一份合适的工作真的不容易，我们常常在这个过程慢慢地失去最初对这个行业的憧憬，但请不要放弃，要相信困难的日子会慢慢过去的。<br>如果你想了解这些年前端的一些感想和经验，也可看<a href="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/">《工作这杯茶》</a>中的前端这几年系列。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文介绍常见的面试流程，以及相关的一些技巧。&lt;br&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发月刊第14期（20200314）</title>
    <link href="https://godbasin.github.io/2020/03/14/wxapp-latest-20200314/"/>
    <id>https://godbasin.github.io/2020/03/14/wxapp-latest-20200314/</id>
    <published>2020-03-14T12:46:50.000Z</published>
    <updated>2020-03-21T01:43:11.351Z</updated>
    
    <content type="html"><![CDATA[<p>这个月大家都开始陆陆续续回去上班了，远程办公的环境也有了一大突破，线上会议的各种延迟和回音有时候依然让人尴尬。不过情况已经慢慢好转，希望各位的日子也会越来越好。<br><a id="more"></a></p><h1 id="小程序-latest"><a href="#小程序-latest" class="headerlink" title="小程序 latest"></a>小程序 latest</h1><h2 id="小程序能力"><a href="#小程序能力" class="headerlink" title="小程序能力"></a>小程序能力</h2><h3 id="安卓微信7-0-12"><a href="#安卓微信7-0-12" class="headerlink" title="安卓微信7.0.12"></a>安卓微信7.0.12</h3><p>本次小程序更新概要如下:</p><ul><li>小程序启动耗时优化，请关注小程序启动是否受影响；</li><li>菜单增加“重新进入小程序”入口，请关注重启后是否正常；</li><li>解决 connectWifi android 10下失败的问题；</li><li>文件接口 readFile 改动，请关注功能是否正常。</li></ul><h2 id="小程序·云开发"><a href="#小程序·云开发" class="headerlink" title="小程序·云开发"></a>小程序·云开发</h2><h3 id="小程序·云开发支持数据库回档"><a href="#小程序·云开发支持数据库回档" class="headerlink" title="小程序·云开发支持数据库回档"></a>小程序·云开发支持数据库回档</h3><p>从开发者工具1.02.202002282版本开始，云开发提供了数据库回档功能。系统会自动开启数据库备份，并于每日凌晨自动进行一次数据备份，最长保存 7 天的备份数据。如有需要，开发者可在云控制台上通过新建回档任务将集合回档（还原）至指定时间点。<br>回档期间，数据库的数据访问不受影响。回档完成后，开发者可在集合列表中看到原有数据库集合和回档后的集合。</p><ul><li>详细功能介绍请参考文档<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/backup.html" target="_blank" rel="external">《数据库回档》</a></li></ul><h3 id="小程序·云开发支持按量付费"><a href="#小程序·云开发支持按量付费" class="headerlink" title="小程序·云开发支持按量付费"></a>小程序·云开发支持按量付费</h3><p>为助力开发者以更低的资源成本实现小程序的功能迭代，从开发者工具1.02.2003022版本开始，小程序·云开发新增按量付费功能。在按量付费模式下，系统每月会提供一定的免费额度供开发者使用，超过免费额度的资源消耗将按照对应的刊例价扣除费用。</p><ul><li>具体按量付费计费策略请参考文档<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/billing/postpayment.html" target="_blank" rel="external">《小程序·云开发按量付费》</a>  </li></ul><p>按量付费功能适用于：</p><ul><li>对于无法准确预估资源使用量的小程序，按量付费功能在保证了正常资源使用的同时，也避免了当用户访问量突增时，由于资源储备不足所导致的超限停服等问题；  </li><li>对于仅使用部分云开发资源类型的小程序，按量付费功能按消耗收费的模式将极大地降低资源成本。  </li></ul><p>开发者可通过登录微信开发者工具的云开发控制台，在环境设置中直接开通按量付费功能。</p><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><h3 id="代码编译和上传-CI-模块"><a href="#代码编译和上传-CI-模块" class="headerlink" title="代码编译和上传 CI 模块"></a>代码编译和上传 CI 模块</h3><p><a href="https://www.npmjs.com/package/miniprogram-ci" target="_blank" rel="external">miniprogram-ci</a> 是从微信开发者工具中抽离的关于小程序/小游戏项目代码的编译模块。该npm 模块，封装了以下逻辑：</p><ul><li>对源代码进行校验</li><li>对源代码进行预编译</li><li>使用证书生成签名</li><li>上传</li></ul><p>使用前需要使用小程序管理员身份访问”微信公众平台-开发-开发设置”后下载代码上传密钥，并配置 IP 白名单（可选，需要注意风险），才能进行上传、预览操作。</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html" target="_blank" rel="external">参考文档地址</a></li></ul><h3 id="微信开发者工具提供-API-Mock-能力"><a href="#微信开发者工具提供-API-Mock-能力" class="headerlink" title="微信开发者工具提供 API Mock 能力"></a>微信开发者工具提供 API Mock 能力</h3><p>为了方便开发者进行功能开发和调试，从 1.02.202003062 版本开始，微信开发者工具提供 API Mock 功能，可模拟如wx.request 、wx.downloadFile 以及 wx.getBackgroundFetchData 等API 的调用结果，极大地降低了小程序的开发成本。</p><ul><li>详细功能介绍请参考文档<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/api-mock.html" target="_blank" rel="external">《API Mock》</a></li></ul><p>API Mock 功能可覆盖的应用场景包括但不限于：</p><ul><li>模拟特定用户场景数据，如通过配置 wx.getLocation 的返回数据，从而模拟位置信息；</li><li>模拟各类异常情况，如通过配置wx.request的回调为 fail，从而模拟网络异常；</li><li>模拟部分微信开发者工具中暂不支持调试的 API，如发票相关的 wx.chooseInvoic等接口。</li><li>开发者可通过登录微信开发者工具，在调试器的 Mock 面板中使用该功能。</li></ul><h3 id="更多更新说明"><a href="#更多更新说明" class="headerlink" title="更多更新说明"></a>更多更新说明</h3><p>参考<a href="https://developers.weixin.qq.com/community/develop/doc/0004064f12424003b90a1758f56c01" target="_blank" rel="external">微信开发者工具 1.02.2003121 RC 更新说明</a>，这期新增能力包括：</p><ol><li>支持 API Mock。</li><li>编辑器支持重命名多个文件。</li><li>支持显示灰度中的基础库、下发测试基础库（该功能只能推送到登录到开发者工具的微信号的手机上，会影响到手机上所有的小程序）。  <ul><li>新增显示灰度中的基础库以及基础库支持的客户端版本。  </li><li>同时新增推送按钮，将选定版本的基础库下发到客户端上，推送结果可以在开发版小程序的调试面板中查看。  </li><li>微信客户端对开发版的小程序打开调试，可以看到测试版基础库的生效时间。  </li></ul></li><li>模拟器支持终止。<ul><li>模拟器是工具的主要功能之一，如果小程序/小游戏的业务代码中出现死循环、复杂运算、频繁调用某些 API 的情况下都会导致工具出现卡顿或者 CPU 占用比较高的情况。模拟器新增终止按钮，点击后可以暂时终止模拟器运行，节省系统资源占用。</li></ul></li><li>打开项目时展示 Loading 状态。<br>工具增加开启加载 loading 弹窗，显示加载状态情况。 </li><li>CLI/HTTP V2 更新。<ul><li>CLI &amp; HTTP 接口升级 v2 版本，在 v2 版本中，旧版命令仍然可以使用，但已废弃并会在未来移除，请使用 v2 命令。v2 版本增加了云开发管理操作支持、优化命令形式、增加细致状态提示、支持长时间命令执行、支持国际化（中英文选择）等。详细文档。</li></ul></li><li>优化云控制台用户访问统计和监控图表的数据展示。<br>支持按照近 7 天、近 30 天以及自定义时间段来筛选 DAU。</li><li>数据库备份回档。</li></ol><p>更多的内容可以查看：</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html" target="_blank" rel="external">稳定版 Stable Build 更新日志</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">开发版 Nightly Build 更新日志</a></li></ul><h1 id="小程序教程"><a href="#小程序教程" class="headerlink" title="小程序教程"></a>小程序教程</h1><h2 id="社区精选文章"><a href="#社区精选文章" class="headerlink" title="社区精选文章"></a>社区精选文章</h2><ul><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000240bb188098d767f9b299956013" target="_blank" rel="external">[填坑手册]小程序新版订阅消息+云开发实战与跳坑</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/0006245c108bf0cd56e9da13651813" target="_blank" rel="external">业务数据怎么查，我用云开发高级日志服务</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/00080c6e3746d8a940f9b43e55fc13" target="_blank" rel="external">只有三行代码的神奇云函数的功能之一：获取openid</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000c6c23708fe0ad46e9dcd215b013" target="_blank" rel="external">借助云开发实现小程序订阅消息和模板消息的推送功能</a></li></ul><p>往期内容可以查看<a href="https://developers.weixin.qq.com/community/develop/article" target="_blank" rel="external">文章分享</a></p><h2 id="最新踩坑-amp-amp-Tips"><a href="#最新踩坑-amp-amp-Tips" class="headerlink" title="最新踩坑 &amp;&amp; Tips"></a>最新踩坑 &amp;&amp; Tips</h2><h3 id="【同步踩坑信息】-云函数"><a href="#【同步踩坑信息】-云函数" class="headerlink" title="【同步踩坑信息】- 云函数"></a>【同步踩坑信息】- 云函数</h3><p>1、小程序冷启动可能导致无状态云函数变成有状态<br>2、避免使用<code>setTimeout</code>等异步调用，而应使用明确状态管理的<code>await</code>或<code>Promise</code><br>3、避免使用<code>cloud.getWXContext()</code>，而使用<code>cloud.getWXContext(context)</code>代替<br>4、用到<code>Date</code>对象的函数应当设置时区环境变量，TZ=Asia/Shanghai</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>如果你也使用Typescript的话，不妨看看我用各种踩坑经验整理的这个<a href="https://github.com/godbasin/wxapp-typescript-demo" target="_blank" rel="external">小程序 typescript 最佳实践 demo</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个月大家都开始陆陆续续回去上班了，远程办公的环境也有了一大突破，线上会议的各种延迟和回音有时候依然让人尴尬。不过情况已经慢慢好转，希望各位的日子也会越来越好。&lt;br&gt;
    
    </summary>
    
      <category term="小程序双皮奶" scheme="https://godbasin.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8C%E7%9A%AE%E5%A5%B6/"/>
    
    
      <category term="教程" scheme="https://godbasin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端面试这件事--1.面试准备</title>
    <link href="https://godbasin.github.io/2020/03/07/interview-1-ready/"/>
    <id>https://godbasin.github.io/2020/03/07/interview-1-ready/</id>
    <published>2020-03-07T08:55:31.000Z</published>
    <updated>2020-03-07T09:39:09.175Z</updated>
    
    <content type="html"><![CDATA[<p>这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文先从一些面试准备方面介绍，缓解下大家的情绪先。<br><a id="more"></a></p><p>通常来说，找工作是一件需要严肃认真对待的事情，它像是职业路上的某个十字路口，一旦走错了可能荒废掉一段光阴。虽然现在习惯跳槽的年轻人越来越多，但对大多数人来说，换工作并不是一件常见的事情，经验的不足常常导致我们对一些预期以外的事情手忙脚乱、犹豫不定。</p><p>本文分享本骚年这些年来面试别人和被人面试的一些经验积累，希望能给到各位求职人一些思考点。</p><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><hr><p>面试也好、答辩也好、分享也罢，我们做任何事情，做好准备是很重要的。在这里，我将面试的准备分成三方面来讲述：​心理准备、简历准备和知识准备。</p><h3 id="1-心理准备"><a href="#1-心理准备" class="headerlink" title="1. 心理准备"></a>1. 心理准备</h3><p>其实只要给予充分的时间准备，以及每次面试后进行复盘和总结，我们总能取得最终的胜利。但更多的时候，我们陷入犹豫的困境，常常是因为我们没有做好心理准备。</p><p>为什么要换工作？这是每个求职者必须要思考的事情，这个问题常常也会被面试官问起。关于这个问题，可以分为内心的答案和表述的答案两种。</p><p>首先是内心的答案。求职者千千万，不同的人有不同的缘由。有些人想要了解外界的情况，有些人想要保持自身的能动性，但大多数的人换工作的原有无非是钱少、工作强度不适合、团队氛围不喜欢、工作内容不感兴趣等。通常来说，我们对当前的工作不满意的因素，会成为我们寻找下一份工作的关注点。如果没有进行足够的思考，我们会陷入换一份工作依然常常不如预期的困境，而频繁跳槽也容易使个人的职业发展受限。</p><p>生活常常不如所愿，更何况一份工作。我们遇到喜欢又如意的工作的概率微乎其微，所以常常需要寻找平衡点。钱多的工作常常强度较大，而适合自己的团队氛围更是难找，所以我们需要做取舍，以及在一定范围内调整自身的心态和预期。这些问题其实平时也可常常思考，这样我们对自身的需求和意愿有较好的认识，对于现有的工作也可以及时地进行调整和适应，而不是让负能量反复积累，或许便不会陷入困境了。</p><p>接下来是表述的答案。为什么有两种答案呢，因为面试官在考察求职者能力的同时也会考察对方的其他品质，求职者希望能获得一份理想的工作，面试官同样也想要招来能力强、负责任又稳定的人。我们换工作的理由本应该是积极的，例如寻求更大的挑战、更感兴趣的工作内容等，但很多时候我们也的确处于各种各样的工作中，像强制性非必要的高强度加班、团队氛围浮夸虚假、组织管理低效不够人性化等。</p><p>我们常常迫于管理上的一些原因更换工作，这些本不应如此、却又无可奈何的问题阻碍了自身的发展和追求，但管理的问题几乎无法避免，所以无法改变的问题可不必再说。职场中常常要求我们带着解决方案来提出问题，所以我们可以用更积极的回答来参与面试，从自身的职业发展角度来描述，而不是执着于上份工作存在的问题。</p><h3 id="2-简历准备"><a href="#2-简历准备" class="headerlink" title="2. 简历准备"></a>2. 简历准备</h3><p>简历准备也是面试准备过程中不可缺少的部分。</p><p>首先是工作内容和技能的关键字。大多数求职过程都是通过投递到HR手中开始，而HR小伙伴们对于专业技能并不了解，所以面试官常常会给到HR一些筛选简历的关键点，例如需要掌握哪些技能、有怎样的项目经验等。我们可以通过网上搜索相应的职位要求，相应地调整简历中的关键字。</p><p>其次是简洁、清晰的工作经验和技能描述。过于臃肿、排版混乱的简历会让面试官较为烦躁，而一目了然的简历会使得面试官心情舒畅。一些比较久远又无法体现个人能力的工作经验，可以省略或概括性描述。所有出现在简历上的内容都需要有足够的把握，避免出现面试官问到又回答不上的尴尬情况，这种情况下面试官会认为简历上的内容并不完全是对方的真实工作内容。</p><p>接下来要突出简历的亮点。项目经验不是越多越好，尽量突出描述有挑战性、体现个人能力的内容。除了专业技能，也可以表现出项目过程中的主动性和思考。</p><p>补充内容。可以针对自身的优势进行一些补充说明，体现个人的能力或是潜力，例如业界认可的一些沉淀、成就。如果你长得特别帅或者漂亮，把照片贴上也不是不可以的。</p><h3 id="3-知识准备"><a href="#3-知识准备" class="headerlink" title="3. 知识准备"></a>3. 知识准备</h3><p>具体的知识准备会在后续篇章详细描述，这里只做简单介绍。</p><p>​首先是刷题。互联网发达的今天，不少人会将自己面试大公司的过程记录下来，同时也常常附有相关的问题和答案，可以作为参考进行同类型​题目的准备。</p><p>理解取代背诵​。我们都是经历过高考的孩子，背东西对我们来说只要花时间就可以解决。但过于僵硬的回答会让面试官失去耐心。如果在记忆的过程中加于理解，结合个人的项目经验来复述，会有更好的效果​。</p><h2 id="面试的技巧"><a href="#面试的技巧" class="headerlink" title="面试的技巧"></a>面试的技巧</h2><hr><h3 id="自信"><a href="#自信" class="headerlink" title="自信"></a>自信</h3><p>自信很重要，如果我们连自己都不相信自己，面试官又如何会觉得你可靠呢？</p><p>自信的培养其实更多在日常生活和工作中，并不是临时准备就可以拥有的。但充分的准备工作也可以一定程度上提升我们的自信心，如果面试官问到的问题都在预期中，当然也可以自信地表达出来了。</p><h3 id="真诚"><a href="#真诚" class="headerlink" title="真诚"></a>真诚</h3><p>真诚地表达自己，个人觉得是面试中最重要的部分。</p><p>我们可以从网上或是书本里学到一些面试技巧，也可以通过各种刷题来获得一些“最优”答案。但如果我们通过掩饰自我而获得了一份工作，这份工作常常会不持久或是不如意。因为面试官看中的是我们“装潢”出来的品质，而不是真实的我们。工作几乎占用我们生命的三分之一时间甚至更多，选择一个真正接纳自己的环境会舒适更多，也更能发挥个人的能力。</p><p>除此之外，专业技能方面若是问到了不懂的内容，诚实地表达出我不会、比强行解释会给面试官留有更好的印象。不懂可以学，但不懂装懂的行为可能会导致工作中或大或小的失误，是不大可取的。当然，你也可以在说出我不会的时候，补充一句我可以学，也可以捡回一两分。</p><h3 id="主动"><a href="#主动" class="headerlink" title="主动"></a>主动</h3><p>很多时候我们会觉得面试过程中自己是处于被动的一方，但其实找工作是双向选择的过程。</p><p>面试官常常要看不少的简历，也需要面试很多人，时间长了会容易疲惫，有时候也不再主动寻找对方的亮点。对求职者来说，适当的主动表现是加分项。我们花费了很多的时间准备，如果面试过程连自身的优势都没有问到就结束了，那我们也永远无法知道自己是否真的匹配不上这个职位。</p><p>在回答问题过程中，可以主动地将话题牵向更能体现个人优势的地方。很多时候，面试官也会问你最擅长或者觉得有挑战性的一些工作内容，也可以做好充足的准备来回答。而主动进行自我补充，有时候也可以带来一些额外的机会。有一次面试过程中，一些比较基础但工作中接触不到的问题我都没答上来，我说只是没准备好，要是准备好了肯定没问题，后来面试官给了一周的准备时间，最终也顺利通过面试。</p><p>另外，我们换工作也有一定的预期，如果这些预期无法从网上或是其他渠道获取，可以在面试的时候主动关注，例如团队氛围、工作内容、工作强度、团队定位等等。既然要换工作，我们当然要尽可能找到一份适合自己的。</p><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><p>大多数人都会在前面几次面试的时候摔跤，但每一次面试后做好复盘是很重要的。</p><p>对于同样的职位，我们在这个面试过程被问到的问题，出现在其他面试的概率很大。所以面试结束后，不管顺利与否，都可以简单记录一下面试过程和相关问题，思考下是否有更好的解决方案、是否有优化的空间。我常常说面试过程会成长很多，也是通过不断地总结、反思、以及二次学习得到的收获。</p><p>除了没有回答好的一些问题以外，我们也可以在面试结束后，让面试官给出一些建议。我们都好为人师，这是大多数面试官都不会拒绝的要求，同时还会给对方留下一定的印象。而面试官给到的一些建议，常常是他们考察候选人的点，我们可以以此来更新对自身的认知。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>找工作真的不容易呀，很久以前我就有写下面试过程的想法，不过一直由于各种事情（懒）而没完成。如今恰好有好些人问起，就一并歇了吧。</p><p>祝各位仕途顺利，越战越勇呀~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些年也有不少的面试别人和面试自己的经历，也有好些人来咨询一些前端的面试题目和准备，所以整理一下记录下来。本文先从一些面试准备方面介绍，缓解下大家的情绪先。&lt;br&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发月刊第13期（20200214）</title>
    <link href="https://godbasin.github.io/2020/02/14/wxapp-latest-20200214/"/>
    <id>https://godbasin.github.io/2020/02/14/wxapp-latest-20200214/</id>
    <published>2020-02-14T11:58:30.000Z</published>
    <updated>2020-02-14T11:59:19.840Z</updated>
    
    <content type="html"><![CDATA[<p>2020年真的是一个doge年，由于春节的原因，一月份没有更新月刊，本篇为2020年开篇月刊。今年的开篇显然有些不友好，祝各位披荆斩棘，越来越好。<br><a id="more"></a></p><h1 id="小程序-latest"><a href="#小程序-latest" class="headerlink" title="小程序 latest"></a>小程序 latest</h1><h2 id="小程序能力"><a href="#小程序能力" class="headerlink" title="小程序能力"></a>小程序能力</h2><h3 id="小程序模板消息开发能力调整说明"><a href="#小程序模板消息开发能力调整说明" class="headerlink" title="小程序模板消息开发能力调整说明"></a>小程序模板消息开发能力调整说明</h3><p>原计划2020年1月10日下线小程序模板消息能力，由于部分开发者反馈尚未完全将模板消息切换为订阅消息，为降低业务影响，现做如下调整：</p><ol><li>下调模板消息接口日调用额度，2020年1月10日起（含1月10日），未开通支付能力的帐号调至5万/日，已开通支付能力的帐号调至50万/日。</li><li>2020年1月10日24:00以后，新发布的小程序，只能使用订阅消息，在该时间点之前发布的小程序仍然可以使用模板消息。（回退的版本，按当前发布时间算）</li><li>2020年4月10日24:00以后，所有版本的小程序都不能使用模板消息，请还未切换使用订阅消息的开发者，在此时间点前完成切换。</li></ol><ul><li><a href="https://developers.weixin.qq.com/community/develop/doc/00008a8a7d8310b6bf4975b635a401?blockType=1" target="_blank" rel="external">小程序模板消息能力调整通知</a></li></ul><h3 id="小程序搜索优化指南-SEO"><a href="#小程序搜索优化指南-SEO" class="headerlink" title="小程序搜索优化指南(SEO)"></a>小程序搜索优化指南(SEO)</h3><p>2019年上半年微信发布了基于小程序页面的搜索，为了让我们更好地发现及理解小程序的页面，结合过去一段时间来我们遇到的各种情况，建议各位开发者阅读<a href="https://developers.weixin.qq.com/community/develop/doc/000a0a1191c3a817e7a9c6f1e51409" target="_blank" rel="external">《小程序搜索优化指南》</a>并结合实际情况进行优化。</p><p>另外，<a href="https://developers.weixin.qq.com/community/develop/doc/00084a1eccc7486a18a91f5815b809" target="_blank" rel="external">微信开放社区成长中心，现正公测</a>。</p><h3 id="商品数据接入（内测）"><a href="#商品数据接入（内测）" class="headerlink" title="商品数据接入（内测）"></a>商品数据接入（内测）</h3><p>商品数据目前应用于微信扫一扫识物、小程序商品搜索和扫条码三个功能。这些功能可以很好的满足微信用户对商品的信息获取诉求，同时也能为商家小程序带来曝光流量和建立用户品牌认知的机会。</p><ul><li>商品数据接入方式请阅读<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/product" target="_blank" rel="external">《商品数据接入文档（内测）》</a></li></ul><h3 id="服务平台新增AI、安全、地图等多项能力"><a href="#服务平台新增AI、安全、地图等多项能力" class="headerlink" title="服务平台新增AI、安全、地图等多项能力"></a>服务平台新增AI、安全、地图等多项能力</h3><p>服务平台新增AI人脸检测、信息安全检查、地理位置、音乐资源等多项接口能力，帮助小程序开发者降低开发门槛、快速接入服务。</p><ul><li><a href="https://developers.weixin.qq.com/community/servicemarket?type=1&amp;channel=4&amp;kw=&amp;serviceType=4" target="_blank" rel="external">可点击前往了解能力详情</a></li></ul><h3 id="“小程序助手”性能分析功能升级"><a href="#“小程序助手”性能分析功能升级" class="headerlink" title="“小程序助手”性能分析功能升级"></a>“小程序助手”性能分析功能升级</h3><p>为了帮助小程序开发者分析性能数据并优化小程序体验，“小程序助手”升级了性能分析功能，新增启动性能、运行性能和网络性能等方面的数据，支持开发者监控小程序的基本性能指标。</p><h3 id="微信-Mac-版小程序开发者公测"><a href="#微信-Mac-版小程序开发者公测" class="headerlink" title="微信 Mac 版小程序开发者公测"></a>微信 Mac 版小程序开发者公测</h3><p>微信 Mac 版新版本中，支持打开聊天中分享的小程序，开发者可下载安装微信 Mac 版公测版本进行体验和适配。最新版微信开发者工具新增支持在微信 Mac 版中预览小程序和进行真机调试。</p><ul><li>详情请查看<a href="https://developers.weixin.qq.com/community/develop/doc/0008ce7eeb870022c4b917e6d5b009" target="_blank" rel="external">《Mac小程序开发说明》</a>。</li><li>微信 Mac 版公测版：<a href="https://dldir1.qq.com/weixin/mac/WeChatMac_Beta.dmg" target="_blank" rel="external">点击下载</a></li></ul><h2 id="小程序·云开发"><a href="#小程序·云开发" class="headerlink" title="小程序·云开发"></a>小程序·云开发</h2><h3 id="小程序·云开发支持数据库事务"><a href="#小程序·云开发支持数据库事务" class="headerlink" title="小程序·云开发支持数据库事务"></a>小程序·云开发支持数据库事务</h3><p>为了方便开发者可以更加灵活地使用数据库能力，满足跨多个记录或跨多集合的原子操作的使用诉求，小程序·云开发新增数据库事务能力。数据库的事务能力保证了在对一个或多个集合进行的一组读写操作中，要么所有的操作都执行成功，要不都不执行，极大地方便了小程序的功能开发。<br>事务过程采用的是快照隔离，在快照隔离中会保证：</p><ol><li>事务期间，读操作返回的是对象的快照，而非实际数据。</li><li>事务期间，写操作会改变快照，保证接下来的读的一致性。同时会给对象加上事务锁。</li><li>事务锁：如果对象上存在事务锁，那么其它事务的写入会直接失败。同时，普通的更新操作会被阻塞，直到事务锁释放或者超时。</li><li>事务提交后，操作完毕的快照会被原子性地写入数据库中。</li></ol><ul><li>目前数据库事务仅支持云函数端使用，同时 wx-server-sdk 最低版本要求 1.7.0</li><li>详细功能介绍请参考文档<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/transaction.html" target="_blank" rel="external">《数据库事务》</a></li></ul><h3 id="周期性更新-数据预拉取支持从云开发环境中获取数据"><a href="#周期性更新-数据预拉取支持从云开发环境中获取数据" class="headerlink" title="周期性更新/数据预拉取支持从云开发环境中获取数据"></a>周期性更新/数据预拉取支持从云开发环境中获取数据</h3><p>周期性更新能够在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。<br>目前，系统已支持从云开发环境中获取数据，并将数据下载到本地。开发者可登录小程序 MP 管理后台，进入设置-&gt;开发设置-&gt;数据周期性更新中进行配置。同时，小程序·云开发还支持数据预拉取功能。</p><ul><li>参考文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/background-fetch.html" target="_blank" rel="external">《周期性更新》</a></li><li>参考文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/pre-fetch.html" target="_blank" rel="external">《数据预拉取》</a>。</li></ul><h3 id="共克时艰，疫情期间，云开发旗舰版免费使用"><a href="#共克时艰，疫情期间，云开发旗舰版免费使用" class="headerlink" title="共克时艰，疫情期间，云开发旗舰版免费使用"></a>共克时艰，疫情期间，云开发旗舰版免费使用</h3><p>小程序·云开发自2020年2月1日至2020年5月1日，为企业、政府、媒体及其他组织小程序用户提供10000个旗舰版套餐免费使用名额，全力助力企业、政府、媒体及其他组织在防控疫情之下， 确保远程协作和研发效率，共渡难关。</p><ul><li><a href="https://developers.weixin.qq.com/community/develop/doc/000424e339ca485a74d92bd415c801" target="_blank" rel="external">查看帖子详情</a></li></ul><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><h3 id="更多更新说明"><a href="#更多更新说明" class="headerlink" title="更多更新说明"></a>更多更新说明</h3><p>参考<a href="https://developers.weixin.qq.com/community/develop/doc/0000240a950c88b392a908d9e51c01" target="_blank" rel="external">微信开发者工具 1.02.1912261 RC 更新说明</a>，这期新增能力包括：</p><ol><li>编辑器优化。</li><li>WXML 支持显示自定义组件数据及实时修改。</li><li>PC 微信调试，支持桌面版微信远程调试。</li><li>清除订阅消息授权数据。</li><li>云控制台支持自定义告警。</li></ol><ul><li>云开发新增自定义告警能力。开发者可以通过告警指标、统计周期、比较条件、持续周期和告警频率等参数的自由组合灵活地配置所需的告警规则</li></ul><ol><li>云控制台高级操作支持数据聚合。</li><li>支持选择安卓设备上的 profile 文件进行分析。</li><li><code>&lt;web-view /&gt;</code>组件的调试入口变更。</li><li>修复项目列表丢失问题及新增项目列表恢复指令。</li><li>云控制台支持自定义数据库读写权限。</li></ol><p>更多的内容可以查看：</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html" target="_blank" rel="external">稳定版 Stable Build 更新日志</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">开发版 Nightly Build 更新日志</a></li></ul><h1 id="小程序教程"><a href="#小程序教程" class="headerlink" title="小程序教程"></a>小程序教程</h1><h2 id="社区精选文章"><a href="#社区精选文章" class="headerlink" title="社区精选文章"></a>社区精选文章</h2><ul><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/0006245c108bf0cd56e9da13651813" target="_blank" rel="external">业务数据怎么查，我用云开发高级日志服务</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/00022217bacab04c8dc9eeaa35c813" target="_blank" rel="external">[kbone-ui]打通 H5/微信小程序 多端UI库</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000224575548480cf5b94254456813" target="_blank" rel="external">商品数据接入（内测）</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000a82b671c2f8eae1a91637d56c13" target="_blank" rel="external">小程序搜索优化指南</a></li></ul><p>往期内容可以查看<a href="https://developers.weixin.qq.com/community/develop/article" target="_blank" rel="external">文章分享</a></p><h2 id="最新踩坑-amp-amp-Tips"><a href="#最新踩坑-amp-amp-Tips" class="headerlink" title="最新踩坑 &amp;&amp; Tips"></a>最新踩坑 &amp;&amp; Tips</h2><h3 id="【同步踩坑信息】-插件开发"><a href="#【同步踩坑信息】-插件开发" class="headerlink" title="【同步踩坑信息】- 插件开发"></a>【同步踩坑信息】- 插件开发</h3><p>插件开发的时候，plugin.json 中一定要指定有效的 main，即使不需要对外提供js接口，也要放一个空的文件，不然开发工具虽然没问题，但是手机会报错。</p><h3 id="同步踩坑信息】-wx-getLaunchOptionsSync使用"><a href="#同步踩坑信息】-wx-getLaunchOptionsSync使用" class="headerlink" title="同步踩坑信息】- wx.getLaunchOptionsSync使用"></a>同步踩坑信息】- wx.getLaunchOptionsSync使用</h3><p><code>wx.getLaunchOptionsSync</code>用来获取小程序启动时的参数，与<code>App.onLaunch</code>的回调参数一致。</p><ul><li>问题：该API只会在小程序初始化的时候记录一次，如果是已经打开小程序，再次打开不能获取最新的启动参数。</li><li>解决方案：可以使用<code>wx.onAppShow</code>绑定监听，来获取最新参数，<code>wx.onAppShow</code>监听小程序切前台事件，该事件与<code>App.onShow</code>的回调参数一致。</li></ul><h3 id="【小程序踩坑记录】-page-onUnload"><a href="#【小程序踩坑记录】-page-onUnload" class="headerlink" title="【小程序踩坑记录】- page.onUnload"></a>【小程序踩坑记录】- page.onUnload</h3><p>在<code>page.onUnload</code>中销毁页面元素，可能导致js错误。<br>原因：unload 由客户端线程调度，界面事件由 webview 线程调度，unload 可能执行比较早，也就是说可能出现 onLoad -&gt; onUnload -&gt; onClickXX（用户操作）-&gt; onVisibleXXX（元素进入可视区域）的情况，所以如果在onUnload回调清空某个对象，那么就会出现对象为空的错误。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最近没看什么书，自己倒是写了一本<a href="https://github.com/godbasin/vue-ebook" target="_blank" rel="external">《深入理解 Vue.js 实战》</a>开源了，欢迎阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年真的是一个doge年，由于春节的原因，一月份没有更新月刊，本篇为2020年开篇月刊。今年的开篇显然有些不友好，祝各位披荆斩棘，越来越好。&lt;br&gt;
    
    </summary>
    
      <category term="小程序双皮奶" scheme="https://godbasin.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8C%E7%9A%AE%E5%A5%B6/"/>
    
    
      <category term="教程" scheme="https://godbasin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Vue.js实战》上线啦</title>
    <link href="https://godbasin.github.io/2020/02/09/vue-ebook/"/>
    <id>https://godbasin.github.io/2020/02/09/vue-ebook/</id>
    <published>2020-02-09T07:40:41.000Z</published>
    <updated>2020-03-07T08:57:50.098Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个多月木有更新了，在写完《9102全员学Vue》系列文章后，对于如何系统学习和理解Vue.js、日常的项目管理和实践又是如何进行，依然有很多可以分享的内容。于是，《深入理解Vue.js实战》上线了。</p><a id="more"></a><h1 id="本书介绍"><a href="#本书介绍" class="headerlink" title="本书介绍"></a>本书介绍</h1><p>《深入理解 Vue.js 实战》是一本开源的 Vue.js 教程，全面介绍 Vue.js 框架的出现、设计和使用，结合实战让读者更深入理解 Vue.js 框架，掌握使用方法。</p><ul><li>本书内容基于 Vue.js 2.x 版本</li><li><a href="https://godbasin.github.io/vue-ebook/">本书地址</a></li><li><a href="https://github.com/godbasin/vue-ebook/" target="_blank" rel="external">本书Github</a></li></ul><h2 id="结构和内容"><a href="#结构和内容" class="headerlink" title="结构和内容"></a>结构和内容</h2><p>本书共分为两部分。第一部分介绍Vue快速入门，结合Vue基础、Vue框架与设计，以及一些简单的代码实例来快速入门。第二部分介绍Vue的正确使用方式，包括在日常开发中，常见的使用方式和项目实战。</p><h4 id="第一部分-Vue快速入门"><a href="#第一部分-Vue快速入门" class="headerlink" title="第一部分 Vue快速入门"></a>第一部分 Vue快速入门</h4><p>该部分包括8章内容：</p><ul><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/1.html">第1章 Vue 框架介绍</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/2.html">第2章 Vue 环境快速搭建</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/3.html">第3章 Vue 基础介绍</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/4.html">第4章 Vue 组件的使用</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/5.html">第5章 常用指令和自定义指令</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/6.html">第6章 Vue 动画</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/7.html">第7章 Vue Router 路由搭建应用</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/8.html">第8章 实战：Todo List 从组件到应用</a></li></ul><h4 id="第二部分-Vue的正确使用方式"><a href="#第二部分-Vue的正确使用方式" class="headerlink" title="第二部分 Vue的正确使用方式"></a>第二部分 Vue的正确使用方式</h4><p>该部分包括8章内容：</p><ul><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/9.html">第9章 思维转变与大型项目管理</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/10.html">第10章 如何正确地进行抽象</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/11.html">第11章 全局数据管理与 Vuex</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/12.html">第12章 实战：三天开发一个管理端</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/13.html">第13章 实战：表单配置化实现</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/14.html">第14章 实战：使用 Webpack 或 Vue CLI 搭建多页应用</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/15.html">第15章 Vue 周边拓展</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/16.html">第16章 关于 Vue 3.0</a></li></ul><p>除此之外，本书分别在<a href="https://godbasin.github.io/vue-ebook/vue-ebook/0.html">前言 前端框架的出现</a>中介绍了前端框架的出现、Vue.js框架原理，以及在<a href="https://godbasin.github.io/vue-ebook/vue-ebook/99.html">后记 关于框架选型</a>中介绍了项目选型要如何进行决策。</p><p>同时，本书相关代码存放在<a href="https://github.com/godbasin/vue-ebook/tree/vue-sourcecode" target="_blank" rel="external">Github vue-sourcecode 分支</a>，书中涉及的代码示例基本可以在这里找到。</p><h2 id="本书说明"><a href="#本书说明" class="headerlink" title="本书说明"></a>本书说明</h2><p>该书的出现源于去年帮助团队的成员快速入门 Vue.js，在写完《9102 全员学 Vue》系列文章后，对于如何系统学习和理解 Vue.js、日常的项目管理和实践又是如何进行，依然有很多可以分享的内容。<br>本书原本在出版计划中，但开源的方式一直是我对该行业和互联网的一丝丝期待和愿景，也十分感谢图灵出版社的张霞编辑的理解和支持。将这些内容整理下来，开源给到更多有需要的人便是我的本意。</p><h2 id="版权许可"><a href="#版权许可" class="headerlink" title="版权许可"></a>版权许可</h2><p>本书采用“保持署名—非商用”创意共享 4.0 许可证。<br>只要保持原作者署名和非商用，您可以自由地阅读、分享、修改本书。<br>详细的法律条文请参见<a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="external">创意共享</a>网站。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>互联网如今有了不少的变化，而这些年的工作沉淀，除了对个人提升之外，是否可以给到社会更大的贡献呢？<br>我一直在思考这个问题，对于2020年的疫情，被称为逆行者的很多一线人员、医护人员此时此刻站在大家前面支撑着，而普通人员除了安分呆在家，我们是否还可以做更多的事情呢？<br>专业所长，似乎只能将自身的一些学习方法、经验沉淀，分享出来，让更多人在面临一些挑战的时候变得不那么艰难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一个多月木有更新了，在写完《9102全员学Vue》系列文章后，对于如何系统学习和理解Vue.js、日常的项目管理和实践又是如何进行，依然有很多可以分享的内容。于是，《深入理解Vue.js实战》上线了。&lt;/p&gt;
    
    </summary>
    
      <category term="vue八宝粥" scheme="https://godbasin.github.io/categories/vue%E5%85%AB%E5%AE%9D%E7%B2%A5/"/>
    
    
      <category term="教程" scheme="https://godbasin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发月刊第12期（20191216）</title>
    <link href="https://godbasin.github.io/2019/12/16/wxapp-latest-20191216/"/>
    <id>https://godbasin.github.io/2019/12/16/wxapp-latest-20191216/</id>
    <published>2019-12-16T15:34:12.000Z</published>
    <updated>2019-12-21T07:46:51.437Z</updated>
    
    <content type="html"><![CDATA[<p>今年最后一刊啦<del>~明年见</del>~<br><a id="more"></a></p><h1 id="小程序-latest"><a href="#小程序-latest" class="headerlink" title="小程序 latest"></a>小程序 latest</h1><h2 id="小程序能力"><a href="#小程序能力" class="headerlink" title="小程序能力"></a>小程序能力</h2><h3 id="小程序代码包总包上限提升至12M"><a href="#小程序代码包总包上限提升至12M" class="headerlink" title="小程序代码包总包上限提升至12M"></a>小程序代码包总包上限提升至12M</h3><p>为了让开发者开发出功能更丰富的小程序，小程序或小游戏代码包总包上限<strong>由8M提升到12M</strong>。建议开发者优化小程序性能并将每个分包做得尽可能小，以便提升用户的打开速度，优化用户体验。</p><h3 id="可以在位置消息中用小程序打车"><a href="#可以在位置消息中用小程序打车" class="headerlink" title="可以在位置消息中用小程序打车"></a>可以在位置消息中用小程序打车</h3><p>为了让用户更便捷地使用小程序的打车服务，我们在位置消息详情页的菜单中，新增了打车小程序入口，详情如下：</p><ol><li>打开聊天中的位置消息，点击详情页右下角绿色按钮，菜单中会展示符合条件的打车小程序，用户可以直接发起目的地为该位置的打车服务。</li><li>小程序的注册类目为“打车（网约车）”，且有用户最近使用的记录，才可以出现在该菜单中。</li><li>在此处点击打开小程序后，需要直接进入到发起打车页面。</li></ol><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/location-message.html" target="_blank" rel="external">接入方法说明</a></li></ul><h3 id="OCR识别能力升级-amp-支持付费购买使用"><a href="#OCR识别能力升级-amp-支持付费购买使用" class="headerlink" title="OCR识别能力升级&amp;支持付费购买使用"></a>OCR识别能力升级&amp;支持付费购买使用</h3><ol><li>基础能力升级。  </li></ol><ul><li>针对少数民族地区身份证进行了识别优化；</li><li>针对独特的身份证样式（如长期身份证及超长住址等）进行了能力升级</li></ul><ol><li>OCR能力支持付费购买使用。</li></ol><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/extended/service-market/intro.html" target="_blank" rel="external">微信OCR识别说明</a></li></ul><h3 id="小程序模板消息开发能力调整说明"><a href="#小程序模板消息开发能力调整说明" class="headerlink" title="小程序模板消息开发能力调整说明"></a>小程序模板消息开发能力调整说明</h3><p>由于小程序模板消息能力将于2020年1月10日下线，请开发者尽快将模板消息切换为订阅消息，以免影响相关业务。近期，我们将对小程序模板消息开发能力进行以下调整：</p><ol><li>2019年12月6日起，小程序帐号将无法添加旧模板，开发者可使用订阅消息，添加订阅模板来进行新业务开发。</li><li>开发者工具将不再支持调试模板消息，仅支持调试订阅消息。</li><li>小程序模板消息接口的日调用量上限将以每周25%的比例逐步下调，具体计划如下：</li></ol><ul><li>2019年12月16日：下调至75%</li><li>2019年12月23日：下调至50%</li><li>2019年12月30日：下调至25%</li><li>2020年1月10日：小程序模板消息接口下线</li></ul><h3 id="微信卡券“刷卡买单”能力即将下线通知"><a href="#微信卡券“刷卡买单”能力即将下线通知" class="headerlink" title="微信卡券“刷卡买单”能力即将下线通知"></a>微信卡券“刷卡买单”能力即将下线通知</h3><p>微信卡券将于2020年1月2日下线微信卡券-微信支付代金券打通券能力（即微信卡券刷卡买单能力）。下线后，创建微信卡券流程中，“核销方式”将不再支持刷卡买单。本次调整仅针对卡券中的代金券类型，折扣券、兑换券、团购券、通用券等券类型不受影响。<br>你可尝试直接创建微信支付代金券作为替代，微信支付代金券同样支持覆盖全流程的 API 接口，创建入口：<a href="https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F" target="_blank" rel="external">微信支付商户平台/服务商平台</a> - 营销中心。  </p><ul><li><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/wxpay/marketing/convention/chapter1_1.shtml" target="_blank" rel="external">API接口参考</a></li></ul><h3 id="关于微信小程序部分类目报备审核说明"><a href="#关于微信小程序部分类目报备审核说明" class="headerlink" title="关于微信小程序部分类目报备审核说明"></a>关于微信小程序部分类目报备审核说明</h3><p>自微信小程序平台上线以来，为了保障小程序内容合规，发布时事新闻、具有社交属性或以视频、电台为载体的小程序需在上线前，完成向省/自治区/直辖市属地网信部门申请报备的工作。特别是，为避免小程序违法违规风险，UGC小程序需要对用户发布的内容做好安全审查措施。</p><ul><li><a href="https://developers.weixin.qq.com/community/operate/doc/00002a6a0b8d98a965993666a51001" target="_blank" rel="external">查看帖子</a></li></ul><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><ul><li><a href="https://developers.weixin.qq.com/community/develop/doc/000c8e132c47c8e19b99a4aa85b001" target="_blank" rel="external">社区问题反馈以及功能优化更新（12.02-12.06）</a>  </li><li><a href="https://developers.weixin.qq.com/community/develop/doc/000886cafa82e043029950a5151001" target="_blank" rel="external">社区问题反馈以及功能优化更新（11.25-11.29）</a>  </li><li><a href="https://developers.weixin.qq.com/community/develop/doc/000c42feb30720b672898a1215b001" target="_blank" rel="external">社区问题反馈以及功能优化更新（11.18-11.22）</a>  </li><li><a href="https://developers.weixin.qq.com/community/develop/doc/0008e47f970a5880cf799f32c5ec01" target="_blank" rel="external">社区问题反馈以及功能优化更新（11.11-11.15）</a>  </li></ul><h2 id="小程序·云开发"><a href="#小程序·云开发" class="headerlink" title="小程序·云开发"></a>小程序·云开发</h2><h3 id="小程序·云开发新增自定义数据库读写权限的能力"><a href="#小程序·云开发新增自定义数据库读写权限的能力" class="headerlink" title="小程序·云开发新增自定义数据库读写权限的能力"></a>小程序·云开发新增自定义数据库读写权限的能力</h3><p>小程序·云开发新增自定义前端数据库读写权限的能力。通过自定义规则，开发者可以精细化的控制集合中所有记录的读、写权限，系统会自动拒绝不符合安全规则的前端数据库请求，保障数据安全。<br>基于该能力，开发者可以：  </p><ol><li>灵活自定义集合记录的读写权限：获得比基础的四种基础权限设置更灵活、强大的读写权限控制，让读写权限控制不再强制依赖于<code>_openid</code>字段和用户 <code>openid</code>。  </li><li>防止越权访问和越权更新：用户只能获取通过安全规则限制的用户所能获取的内容，越权获取数据将被拒绝。  </li><li>限制新建数据的内容：让新建数据必须符合规则，如可以要求权限标记字段必须为用户<code>openid</code>开发者可通过下载最新 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">Nightly版</a> 开发者工具体验功能。</li></ol><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/security-rules.html#%E7%AE%80%E4%BB%8B" target="_blank" rel="external">数据库安全规则参考</a></li></ul><h3 id="小程序·云开发新增自定义告警能力"><a href="#小程序·云开发新增自定义告警能力" class="headerlink" title="小程序·云开发新增自定义告警能力"></a>小程序·云开发新增自定义告警能力</h3><p>为了方便开发者及时发现小程序运行过程中发生的异常，小程序·云开发新增自定义告警能力。开发者可以通过告警指标、统计周期、比较条件、持续周期和告警频率等参数的自由组合灵活地配置所需的告警规则。 开发者可通过下载最新 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">Nightly版</a> 开发者工具体验功能。</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/alarm.html" target="_blank" rel="external">告警设置参考</a></li></ul><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><h3 id="微信开发者工具功能更新！"><a href="#微信开发者工具功能更新！" class="headerlink" title="微信开发者工具功能更新！"></a>微信开发者工具功能更新！</h3><p>为提高代码编辑效率和优化开发体验，微信开发者工具的编辑器功能进行了全面升级，并对产品 Logo 进行了更新：<br><img src="https://mmbiz.qlogo.cn/mmbiz_png/UB2CE27Dppm0h0zPD1HXMSMAjKXDWFTibibhzRueUYptye69ZahU3yzrLrOic1jEYyWJPcYicnsf5PveuJPD5F4ia7Q/0?wx_fmt=png" alt=""></p><ol><li>编辑器功能优化：</li></ol><ul><li>新增大纲结构视图和文件的面包屑导航，同时编辑区域还支持分栏视图，方便开发者同时查看和编辑多个文件。</li><li>优化了文件搜索功能，支持更加精细化地搜索和替换功能，进一步提高了开发者的操作效率。</li><li>在编写 JS/TS 文件时，编辑器现在提供完整的项目代码补全和联想功能，使用 TS 的语言服务分析并提供代码错误及警告提示。</li></ul><ol><li>兼容部分 VS Code 扩展 （Beta）：<br>新版微信开发者工具编辑器兼容了部分 VS Code 扩展插件，目前正在功能完善阶段。开发者可根据需要安装对应插件，进一步提高开发效率。</li></ol><p>开发者可通过下载最新 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">Nightly版</a> 开发者工具体验功能。</p><h3 id="内置扩展库支持"><a href="#内置扩展库支持" class="headerlink" title="内置扩展库支持"></a>内置扩展库支持</h3><p>方便开发者使用，最新的 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">Nightly版</a> 开发者工具支持了内置扩展库，开发者只需在app.json配置文件声明引用指定扩展库即可，无需自行引入相关 npm 包且不计入小程序代码包大小，目前支持了kbone和WeUI两种扩展库，更多详情请参考文档。</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/extended/weui/" target="_blank" rel="external">拓展能力说明</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#useExtendedLib" target="_blank" rel="external">配置使用说明</a></li></ul><blockquote><p>工具里不计入总包大小，但是下载代码包依然会变大噢</p></blockquote><h3 id="更多更新说明"><a href="#更多更新说明" class="headerlink" title="更多更新说明"></a>更多更新说明</h3><p>更多的内容可以查看：</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html" target="_blank" rel="external">稳定版 Stable Build 更新日志</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/nightly.html" target="_blank" rel="external">开发版 Nightly Build 更新日志</a></li></ul><h1 id="小程序教程"><a href="#小程序教程" class="headerlink" title="小程序教程"></a>小程序教程</h1><h2 id="社区精选文章"><a href="#社区精选文章" class="headerlink" title="社区精选文章"></a>社区精选文章</h2><ul><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/0008424ea884e83b47895f5c45b813" target="_blank" rel="external">揭开微信小程序 Kbone 的神秘面纱</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/00088ebe4e0500035999338cb56813" target="_blank" rel="external">小程序奇技淫巧之 – globalDataBehavior管理全局状态</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/00006c4afb0d28925699bba915b013" target="_blank" rel="external">小程序奇技淫巧之 – 日志能力</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000a0a78a582d0e053997a1c05b813" target="_blank" rel="external">小程序奇技淫巧之 – 页面跳转管理</a></li></ul><p>往期内容可以查看<a href="https://developers.weixin.qq.com/community/develop/article" target="_blank" rel="external">文章分享</a></p><h2 id="最新踩坑-amp-amp-Tips"><a href="#最新踩坑-amp-amp-Tips" class="headerlink" title="最新踩坑 &amp;&amp; Tips"></a>最新踩坑 &amp;&amp; Tips</h2><h3 id="【同步踩坑信息】-小程序换行会导致多余空格"><a href="#【同步踩坑信息】-小程序换行会导致多余空格" class="headerlink" title="【同步踩坑信息】- 小程序换行会导致多余空格"></a>【同步踩坑信息】- 小程序换行会导致多余空格</h3><p>一般使用编辑器开发，格式化会导致一些换行，在小程序里会导致多余空格，如图：<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/wxapp-latest-20191015.png" alt=""><br>经小程序团队定位，win 版换行符 \r\n 会有问题，浏览器也会。可以修改各自的编辑器的换行符使用 \n 可以解决。</p><ul><li>VS Code：Setting -&gt; Text Editor -&gt; Files -&gt; Eol -&gt; 设置为 \n</li></ul><h3 id="【同步开发Tips】-手机宽高比"><a href="#【同步开发Tips】-手机宽高比" class="headerlink" title="【同步开发Tips】- 手机宽高比"></a>【同步开发Tips】- 手机宽高比</h3><p>ios最小高宽比一般是960 x 640也就是我们的iPhone 比例是1.5，android最小宽高比960 x 540 比例是1.777777778。所以最小比例我们可以参考iPhone4，最大比例没有限制，因为手机屏幕只会越来越大，但是比例来来回回就是2.16的。</p><h3 id="【同步开发Tips】-小程序转发"><a href="#【同步开发Tips】-小程序转发" class="headerlink" title="【同步开发Tips】- 小程序转发"></a>【同步开发Tips】- 小程序转发</h3><p>小程序里控制右上角的转发行为方式：</p><ol><li>动态显隐转发按钮<code>wx.showShareMenu</code>、<code>wx.hideShareMenu</code>。</li><li>不定义<code>onShareAppMessage</code>，默认不会有转发。</li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我们倾向于以结果判断决定——而不是当时作决定的过程。这种思维错误又名史学家错误。– 《清醒思考的艺术》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年最后一刊啦&lt;del&gt;~明年见&lt;/del&gt;~&lt;br&gt;
    
    </summary>
    
      <category term="小程序双皮奶" scheme="https://godbasin.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8C%E7%9A%AE%E5%A5%B6/"/>
    
    
      <category term="教程" scheme="https://godbasin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>小程序奇技淫巧之页面跳转管理</title>
    <link href="https://godbasin.github.io/2019/12/08/wxapp-navigate/"/>
    <id>https://godbasin.github.io/2019/12/08/wxapp-navigate/</id>
    <published>2019-12-08T11:12:08.000Z</published>
    <updated>2019-12-14T05:01:23.475Z</updated>
    
    <content type="html"><![CDATA[<p>小程序页面跳转也是一个很容易踩到坑的开发流程，本文介绍页面跳转相关的一些好用的实践和封装的组件库。<br><a id="more"></a></p><h2 id="小程序页面跳转"><a href="#小程序页面跳转" class="headerlink" title="小程序页面跳转"></a>小程序页面跳转</h2><hr><p>一个小程序可以有很多页面，每个页面承载不同的功能，页面之间可以互相跳转。我们知道，小程序分为渲染层和逻辑层，渲染层中包含了多个 WebView，每个 WebView 对应到我们的小程序里就是一个页面 Page，每一个页面都独立运行在一个页面层级上，如图：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/wxapp-navigate-1.png" alt=""></p><h3 id="页面栈管理"><a href="#页面栈管理" class="headerlink" title="页面栈管理"></a>页面栈管理</h3><p>一个小程序拥有多个页面，我们知道<code>wx.navigateTo</code>可以推入一个新的页面。我们看看小程序示例小程序里，在首页使用2次<code>wx.navigateTo</code>后，页面层级会有三层：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/wxapp-17.jpg" alt="">  </p><p>我们把这样的一个页面层级称为页面栈。在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了当前的所有页面。小程序中页面栈最多十层，也就是十个 WebView，如果超过了十个之后，就没法再打开新的页面了。</p><p>对于每一个新的页面层级，渲染层都需要进行一些额外的准备工作。在小程序启动前，客户端会提前准备好一个页面层级用于展示小程序的首页。除此以外，每当一个页面层级被用于渲染页面，客户端都会提前开始准备一个新的页面层级，使得每次调用<code>wx.navigateTo</code>都能够尽快展示一个新的页面。</p><h3 id="页面间跳转"><a href="#页面间跳转" class="headerlink" title="页面间跳转"></a>页面间跳转</h3><p>小程序启动时仅有一个页面层级，而在小程序运行中，页面之间的跳转表现包括这些：  </p><table><thead><tr><th>API</th><th>页面表现</th><th>页面栈表现</th></tr></thead><tbody><tr><td><code>wx.navigateTo</code></td><td>保留当前页面，跳转到应用内的某个页面</td><td>创建一个新的页面层级</td></tr><tr><td><code>wx.navigateBack</code></td><td>关闭当前页面，返回上一页面或多级页面</td><td>销毁一个页面层级</td></tr><tr><td><code>wx.redirectTo</code></td><td>关闭当前页面，跳转到应用内的某个页面</td><td>将当前页面层级重新初始化。重新传入页面的初始数据、路径等，视图层清空当前页面层级的渲染结果然后重新渲染页面</td></tr><tr><td><code>wx.reLaunch</code></td><td>关闭所有页面，打开到应用内的某个页面</td><td>销毁所有页面层级，再创建一个新的页面层级</td></tr><tr><td><code>wx.switchTab</code></td><td>关闭其他所有非 tabBar 页面，跳转到 tabBar 页面</td><td>销毁所有非 tabBa 页面层级，打开tabBar页面层级</td></tr></tbody></table><p>上面提到了 tabBar。除了普通的页面跳转，小程序里还支持配置 tabBar。tabBar 就是类似客户端 APP 底部的 tab 切换，为了获得更好的体验，小程序提供了这样的全局组件，在 app.json 文件中设置 tabBar，因此我们小程序会区分 tabBar 页面和非 tabBar 页面。tabBar 页面之间的切换都只会有一个层级，而跳转到非 tabBar 页面之后，就有了页面层级和页面栈的管理。</p><h2 id="页面跳转技巧"><a href="#页面跳转技巧" class="headerlink" title="页面跳转技巧"></a>页面跳转技巧</h2><hr><p>小程序的 JS 脚本是运行在 JsCore 的线程里，小程序的每个页面各自有一个 WebView 线程进行渲染，所以小程序切换页面时，小程序逻辑层的 JS 脚本运行上下文依旧在同一个 JsCore 线程中。</p><p>因为在同一个 JsCore 线程中，我们就会有一些问题会遇到，也可以有一些小技巧来处理。</p><h3 id="判断跳转来源"><a href="#判断跳转来源" class="headerlink" title="判断跳转来源"></a>判断跳转来源</h3><p>由于切换页面后，业务逻辑依然在同一个 JsCore 线程中。因此，即使是小程序页面被关闭 unload 之后，如果有原本在执行的逻辑，会继续执行完毕。</p><p>在这样的情况下，如果有重定向、跳转等逻辑，在跳转之后后续的逻辑依然会继续执行，这时候如果还有其他的跳转逻辑，可能会导致页面连续跳转，严重的话跳转参数丢书会导致白屏。</p><p>为了防止用户自行返回等操作，可以添加当前页面的条件判断是否要执行，页面栈可以通过<code>getCurrentPages</code>拿到，例如我们可以添加这样的方法处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理是否有当前路由</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchOriginPath</span>(<span class="params">originPageUrl</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> currentPages = getCurrentPages();</div><div class="line">  <span class="keyword">const</span> currentPage = currentPages[currentPages.length - <span class="number">1</span>].route;</div><div class="line">  <span class="comment">// 判断是否设置了特定页面才进行跳转</span></div><div class="line">  <span class="comment">// 如果设置了，判断当前页面是否特定页面，是才跳转</span></div><div class="line">  <span class="comment">// 用于判断当前页面是否已经被跳转走（用户手动关闭等）</span></div><div class="line">  <span class="keyword">const</span> isMatch = !originPageUrl || (originPageUrl &amp;&amp; currentPage.indexOf(originPageUrl) &gt; <span class="number">-1</span>);</div><div class="line">  <span class="comment">// 如果设置了，当页面路径不匹配，则进行报错提示</span></div><div class="line">  <span class="keyword">if</span> (!isMatch) &#123;</div><div class="line">    <span class="built_in">console</span>.error(</div><div class="line">      <span class="string">"matchOriginPath do not match"</span>,</div><div class="line">      <span class="string">`currentPage: <span class="subst">$&#123;currentPage&#125;</span>, originPageUrl: <span class="subst">$&#123;originPageUrl&#125;</span>`</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isMatch;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过这样的检查方式，我们可以通过传参来判断下是否要检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 跳转到页面</div><div class="line"> * @param &#123;object&#125; url 要跳转的页面地址</div><div class="line"> * @param &#123;object&#125; originPageUrl 原始页面地址，用于判断来源是否符合</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">navigateTo</span>(<span class="params">url: string, originPageUrl?: string</span>) </span>&#123;</div><div class="line">  <span class="comment">// 不符合源页面条件则不跳转</span></div><div class="line">  <span class="keyword">if</span> (!matchOriginPath(originPageUrl!)) &#123;</div><div class="line">    logger.RUN(<span class="string">"navigateTo"</span>, <span class="string">"originPageUrl != currentPage, return"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(url);</div><div class="line">  wx.navigateTo(&#123; url &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，我们跳转的时候可以添加参数，预防页面非预期的跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">navigateTo(&#123;<span class="attr">url</span>: <span class="string">'/pages/pageB'</span>&#125;, <span class="string">'/pages/pageA'</span>);</div><div class="line"><span class="comment">// 后面的逻辑在页面跳转之后，不会再生效</span></div><div class="line">navigateTo(&#123;<span class="attr">url</span>: <span class="string">'/pages/pageC'</span>&#125;, <span class="string">'/pages/pageA'</span>);</div></pre></td></tr></table></figure><h3 id="跳转传参"><a href="#跳转传参" class="headerlink" title="跳转传参"></a>跳转传参</h3><p>小程序提供的跳转相关 API，需要在 url 后面添加参数的方式来传参，但有些时候我们不仅仅需要携带简单的字符串或者数字，我们还可能需要携带一个较大的对象数据。那么这种情况下，由于小程序页面切换依然在同一个 JsCore 上下文，我们可以通过共享对象的方式来传递。</p><p>共享对象需要在公共库中存储一个当前跳转的传参内容，同时为了避免页面同时跳转导致传参内容不匹配，我们可以通过一个随机 ID 的方式来标记：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getRandomId</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 时间戳（9位） + 随机串（10位）</span></div><div class="line">  <span class="keyword">return</span> (<span class="built_in">Date</span>.now()).toString(<span class="number">32</span>) + <span class="built_in">Math</span>.random().toString(<span class="number">32</span>).substring(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>跳转的时候，我们可以根据 url 传参的方式，还是共享对象传参的方式，来进行不同的判断处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> globalPageParams = <span class="literal">undefined</span>; <span class="comment">// 全局页面跳转参数</span></div><div class="line"><span class="keyword">let</span> globalPageParamsId: any = <span class="literal">undefined</span>; <span class="comment">// 全局页面跳转参数Id，用于标识某一次跳转的数据</span></div><div class="line"></div><div class="line"><span class="comment">// 跳转时参数处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mangeUrl</span>(<span class="params">url, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; urlParams, pageParams &#125; = options;</div><div class="line"></div><div class="line">  <span class="comment">// url参数处理</span></div><div class="line">  <span class="keyword">if</span> (urlParams) &#123;</div><div class="line">    url = addUrlParams(url, urlParams);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 页面参数处理</span></div><div class="line">  <span class="keyword">if</span> (pageParams) &#123;</div><div class="line">    globalPageParams = objectCopy(pageParams);</div><div class="line">    <span class="comment">// 获取随机 ID</span></div><div class="line">    globalPageParamsId = getRandomId();</div><div class="line">    <span class="comment">// 将随机 ID 带入 url 参数中，可用来获取全局参数</span></div><div class="line">    url = addUrlParams(url, &#123; <span class="attr">randomid</span>: globalPageParamsId &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    globalPageParams = <span class="literal">undefined</span>;</div><div class="line">    globalPageParamsId = <span class="literal">undefined</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> url;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，我们的跳转方法可以这么处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 跳转到页面</div><div class="line"> * @param &#123;object&#125; url 要跳转的页面地址</div><div class="line"> * @param &#123;object&#125; options 要携带的参数信息</div><div class="line"> * @param &#123;object&#125; originPageUrl 原始页面地址，用于判断来源是否符合</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">navigateTo</span>(<span class="params">url, options = &#123;&#125;, originPageUrl</span>) </span>&#123;</div><div class="line">  url = mangeUrl(url, options);</div><div class="line"></div><div class="line">  <span class="comment">// 不符合源页面条件则不跳转</span></div><div class="line">  <span class="keyword">if</span> (!matchOriginPath(originPageUrl!)) &#123;</div><div class="line">    logger.RUN(<span class="string">"navigateTo"</span>, <span class="string">"originPageUrl != currentPage, return"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</div><div class="line">  &#125;</div><div class="line">  wx.navigateTo(&#123; url &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结合-Component-自动取参"><a href="#结合-Component-自动取参" class="headerlink" title="结合 Component 自动取参"></a>结合 Component 自动取参</h3><p>我们有介绍过如何使用 Component 来开发页面，使用 Component 有几个好处：</p><ol><li>可以通过 Behavior 来拓展组件的通用能力。</li><li>可以直接通过定义 properties 来获取页面参数。</li></ol><blockquote><p>页面如何使用 Behavior<br>看看<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html" target="_blank" rel="external">官方文档</a>：事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用<code>Component</code>构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应<code>json</code>文件中包含<code>usingComponents</code>定义段。</p></blockquote><p>这里配合跳转传参，我们可以省略很多的逻辑。例如我们有一个结果页面，页面展示直接从 url 中取值（如果使用 Page 的 query 方式获取参数，需要自己进行  decodeURIComponent 才能使用，而使用组件的 properties 则不需要）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Component(&#123;</div><div class="line">  <span class="comment">// 其他配置省略</span></div><div class="line">  properties: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="built_in">String</span>,  <span class="comment">// 结果类型，成功-success，失败-warn</span></div><div class="line">    title: <span class="built_in">String</span>, <span class="comment">// 主要文案</span></div><div class="line">    info: <span class="built_in">String</span> <span class="comment">// 辅助文案</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们这样进行跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">navigateTo(<span class="string">"/pages/result/result"</span>, &#123;</div><div class="line">  <span class="comment">// 直接带入参数，result组件可通过properties直接拿到</span></div><div class="line">  urlParams: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"success"</span>,</div><div class="line">    <span class="attr">title</span>: <span class="string">"操作成功"</span>,</div><div class="line">    <span class="attr">info</span>: <span class="string">"成功就是这么简单"</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>则可以直接在模板中显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 使用的 weui 组件库 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">weui-msg</span> <span class="attr">type</span>=<span class="string">"&#123;&#123;type&#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123;title&#125;&#125;"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">slot</span>=<span class="string">"desc"</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">weui-msg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure><p>如果是通过页面传参的方式，则需要通过随机 ID 来获取对应的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过随机 ID 获取对应参数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPageParams</span>(<span class="params">randomId</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (globalPageParamsId === randomId) &#123;</div><div class="line">    <span class="keyword">return</span> globalPageParams || &#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>组件中可以通过 properties 来获取随机 ID，然后获取对应参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Component(&#123;</div><div class="line">  <span class="comment">// 其他配置省略</span></div><div class="line">  properties: &#123;</div><div class="line">    <span class="attr">randomid</span>: <span class="built_in">String</span>,  <span class="comment">// 随机 ID</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    onLoad() &#123;</div><div class="line">      <span class="comment">// 获取参数</span></div><div class="line">      <span class="keyword">const</span> params = getPageParams(<span class="keyword">this</span>.data.randomid);</div><div class="line">      <span class="comment">// 处理参数</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>具体的代码实现，可参考项目代码：<a href="https://github.com/godbasin/wxapp-typescript-demo" target="_blank" rel="external">wxapp-typescript-demo</a>。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=000a64a29c48b0eb0086f161b5940a" target="_blank" rel="external">7.2 页面层级准备</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html" target="_blank" rel="external">Component构造器</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" target="_blank" rel="external">behaviors</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><hr><p>使用自定义组件的方式来开发页面，简直不能太赞啦。通过 Behavior 来各种拓展组件的能力，同时还能简化一些取参的逻辑，还是特别方便的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序页面跳转也是一个很容易踩到坑的开发流程，本文介绍页面跳转相关的一些好用的实践和封装的组件库。&lt;br&gt;
    
    </summary>
    
      <category term="小程序双皮奶" scheme="https://godbasin.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8C%E7%9A%AE%E5%A5%B6/"/>
    
    
      <category term="教程" scheme="https://godbasin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>小程序奇技淫巧之日志能力</title>
    <link href="https://godbasin.github.io/2019/12/07/wxapp-logs/"/>
    <id>https://godbasin.github.io/2019/12/07/wxapp-logs/</id>
    <published>2019-12-07T05:42:28.000Z</published>
    <updated>2019-12-14T05:01:40.724Z</updated>
    
    <content type="html"><![CDATA[<p>小程序定位问题也是一大难题，而官方提供了 LogManager 和实时日志，这两个能力是如何结合使用、是否还有更便捷的方式来使用呢？<br><a id="more"></a></p><h2 id="日志与反馈"><a href="#日志与反馈" class="headerlink" title="日志与反馈"></a>日志与反馈</h2><hr><p>前端开发在进行某个问题定位的时候，日志是很重要的。因为机器兼容性问题、环境问题等，我们常常无法复现用户的一些bug。而微信官方也提供了较完整的日志能力，我们一起来看一下。</p><h3 id="用户反馈"><a href="#用户反馈" class="headerlink" title="用户反馈"></a>用户反馈</h3><p>小程序官方提供了用户反馈携带日志的能力，大概流程是：  </p><ol><li>开发中日志打印，使用日志管理器实例 LogManager。  </li><li>用户在使用过程中，可以在小程序的 profile 页面（【右上角胶囊】-【关于xxxx】），点击【投诉与反馈】-【功能异常】（旧版本还需要勾选上传日志），则可以上传日志。</li><li>在小程序管理后台，【管理】-【反馈管理】，就可以查看上传的日志（还包括了很详细的用户和机型版本等信息）。 </li></ol><p>这个入口可能对于用户来说过于深入（是的，官方也发现这个问题了，所以后面有了实时日志），我们小程序也可以通过<code>button</code>组件，设置<code>openType</code>为<code>feedback</code>，然后用户点击按钮就可以直接拉起意见反馈页面了。利用这个能力，我们可以监听用户截屏的操作，然后弹出浮层引导用户主动进行反馈。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;view class="dialog" wx:if="&#123;&#123;isFeedbackShow&#125;&#125;"&gt;</div><div class="line">  &lt;view&gt;是否遇到问题？&lt;/view&gt;</div><div class="line">  &lt;button open-type="feedback"&gt;点击反馈&lt;/button&gt;</div><div class="line">&lt;/view&gt;</div><div class="line"></div><div class="line">wx.onUserCaptureScreen(() =&gt; &#123;</div><div class="line">  // 设置弹窗出现</div><div class="line">  this.setData(&#123;isFeedbackShow: true&#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="LogManager"><a href="#LogManager" class="headerlink" title="LogManager"></a>LogManager</h3><p>关于小程序的 LogManager，大概是非常实用又特别低调的一个能力了。它的使用方式其实和 console 很相似，提供了 log、info、debug、warn 等日志方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> logger = wx.getLogManager()</div><div class="line">logger.log(&#123;<span class="attr">str</span>: <span class="string">'hello world'</span>&#125;, <span class="string">'basic log'</span>, <span class="number">100</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">logger.info(&#123;<span class="attr">str</span>: <span class="string">'hello world'</span>&#125;, <span class="string">'info log'</span>, <span class="number">100</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">logger.debug(&#123;<span class="attr">str</span>: <span class="string">'hello world'</span>&#125;, <span class="string">'debug log'</span>, <span class="number">100</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">logger.warn(&#123;<span class="attr">str</span>: <span class="string">'hello world'</span>&#125;, <span class="string">'warn log'</span>, <span class="number">100</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure><p>打印的日志，从管理后台下载下来之后，也是很好懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">2019-6-25 22:11:6 [log] wx.setStorageSync api invoke</div><div class="line">2019-6-25 22:11:6 [log] wx.setStorageSync return</div><div class="line">2019-6-25 22:11:6 [log] wx.setStorageSync api invoke</div><div class="line">2019-6-25 22:11:6 [log] wx.setStorageSync return</div><div class="line">2019-6-25 22:11:6 [log] [v1.1.0] request begin</div><div class="line">2019-6-25 22:11:6 [log] wx.request api invoke with seq 0</div><div class="line">2019-6-25 22:11:6 [log] wx.request success callback with msg request:ok with seq 0</div><div class="line">2019-6-25 22:11:6 [log] [v1.1.0] request done</div><div class="line">2019-6-25 22:11:7 [log] wx.navigateTo api invoke</div><div class="line">2019-6-25 22:11:7 [log] page packquery/pages/index/index onHide have been invoked</div><div class="line">2019-6-25 22:11:7 [log] page packquery/pages/logs/logs onLoad have been invoked</div><div class="line">2019-6-25 22:11:7 [log] [v1.1.0] logs  |  onShow  |    |  []</div><div class="line">2019-6-25 22:11:7 [log] wx.setStorageSync api invoke</div><div class="line">2019-6-25 22:11:7 [log] wx.setStorageSync return</div><div class="line">2019-6-25 22:11:7 [log] wx.reportMonitor api invoke</div><div class="line">2019-6-25 22:11:7 [log] page packquery/pages/logs/logs onShow have been invoked</div><div class="line">2019-6-25 22:11:7 [log] wx.navigateTo success callback with msg navigateTo:ok</div></pre></td></tr></table></figure><p>LogManager 最多保存 5M 的日志内容，超过5M后，旧的日志内容会被删除。基础库默认会把 App、Page 的生命周期函数和 wx 命名空间下的函数调用写入日志，基础库的日志帮助我们定位具体哪些地方出了问题。</p><h3 id="实时日志"><a href="#实时日志" class="headerlink" title="实时日志"></a>实时日志</h3><p>小程序的 LogManager 有一个很大的痛点，就是必须依赖用户上报，入口又是右上角胶囊-【关于xxxx】-【投诉与反馈】-【功能异常】这么长的路径，甚至用户的反馈过程也会经常丢失日志，导致无法查问题。</p><p>为帮助小程序开发者快捷地排查小程序漏洞、定位问题，微信推出了实时日志功能。从基础库 2.7.1 开始，开发者可通过提供的接口打印日志，日志汇聚并实时上报到小程序后台。</p><p>使用方式如下：  </p><ol><li>使用 wx.getRealtimeLogManager 在代码⾥⾯打⽇志。  </li><li>可从小程序管理后台【开发】-【运维中心】-【实时日志】进入日志查询页面，查看开发者打印的日志信息。  </li></ol><p>开发者可通过设置时间、微信号/OpenID、页面链接、FilterMsg内容（基础库2.7.3及以上支持setFilterMsg）等筛选条件查询指定用户的日志信息:</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/wxapp-logs-1.png" alt=""></p><p>由于后台资源限制，实时日志使用规则如下：  </p><ol><li>为了定位问题方便，日志是按页面划分的，某一个页面，在onShow到onHide（切换到其它页面、右上角圆点退到后台）之间打的日志，会聚合成一条日志上报，并且在小程序管理后台上可以根据页面路径搜索出该条日志。</li><li>每个小程序账号每天限制500万条日志，日志会保留7天，建议遇到问题及时定位。<br>一条日志的上限是5KB，最多包含200次打印日志函数调用（info、warn、error调用都算），所以要谨慎打日志，避免在循环里面调用打日志接口，避免直接重写console.log的方式打日志。</li><li>意见反馈里面的日志，可根据OpenID搜索日志。</li><li>setFilterMsg 可以设置过滤的 Msg。这个接口的目的是提供某个场景的过滤能力，例如<code>setFilterMsg(&#39;scene1&#39;)</code>，则在 MP 上可输入 scene1 查询得到该条日志。比如上线过程中，某个监控有问题，可以根据 FilterMsg 过滤这个场景下的具体的用户日志。FilterMsg 仅支持大小写字母。如果需要添加多个关键字，建议使用 addFilterMsg 替代 setFilterMsg。</li></ol><h2 id="日志开发技巧"><a href="#日志开发技巧" class="headerlink" title="日志开发技巧"></a>日志开发技巧</h2><hr><p>既然官方提供了 LogManager 和实时日志，我们当然是两个都要用啦。</p><h3 id="log-js"><a href="#log-js" class="headerlink" title="log.js"></a>log.js</h3><p>我们将所有日志的能力都封装在一起，暴露一个通用的接口给调用方使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// log.js</span></div><div class="line"><span class="keyword">const</span> VERSION = <span class="string">"0.0.1"</span>; <span class="comment">// 业务代码版本号，用户灰度过程中观察问题</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> canIUseLogManage = wx.canIUse(<span class="string">"getLogManager"</span>);</div><div class="line"><span class="keyword">const</span> logger = canIUseLogManage ? wx.getLogManager(&#123;<span class="attr">level</span>: <span class="number">0</span>&#125;) : <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> realtimeLogger = wx.getRealtimeLogManager ? wx.getRealtimeLogManager() : <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;string&#125; file 所在文件名</div><div class="line"> * @param  &#123;...any&#125; arg 参数</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">DEBUG</span>(<span class="params">file, ...args</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.debug(file, <span class="string">" | "</span>, ...args);</div><div class="line">  <span class="keyword">if</span> (canIUseLogManage) &#123;</div><div class="line">    logger!.debug(<span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>]`</span>, file, <span class="string">" | "</span>, ...args);</div><div class="line">  &#125;</div><div class="line">  realtimeLogger &amp;&amp; realtimeLogger.info(<span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>]`</span>, file, <span class="string">" | "</span>, ...args);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * @param &#123;string&#125; file 所在文件名</div><div class="line"> * @param  &#123;...any&#125; arg 参数</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">RUN</span>(<span class="params">file, ...args</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(file, <span class="string">" | "</span>, ...args);</div><div class="line">  <span class="keyword">if</span> (canIUseLogManage) &#123;</div><div class="line">    logger!.log(<span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>]`</span>, file, <span class="string">" | "</span>, ...args);</div><div class="line">  &#125;</div><div class="line">  realtimeLogger &amp;&amp; realtimeLogger.info(<span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>]`</span>, file, <span class="string">" | "</span>, ...args);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * @param &#123;string&#125; file 所在文件名</div><div class="line"> * @param  &#123;...any&#125; arg 参数</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ERROR</span>(<span class="params">file, ...args</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(file, <span class="string">" | "</span>, ...args);</div><div class="line">  <span class="keyword">if</span> (canIUseLogManage) &#123;</div><div class="line">    logger!.warn(<span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>]`</span>, file, <span class="string">" | "</span>, ...args);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (realtimeLogger) &#123;</div><div class="line">    realtimeLogger.error(<span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>]`</span>, file, <span class="string">" | "</span>, ...args);</div><div class="line">    <span class="comment">// 判断是否支持设置模糊搜索</span></div><div class="line">    <span class="comment">// 错误的信息可记录到 FilterMsg，方便搜索定位</span></div><div class="line">    <span class="keyword">if</span> (realtimeLogger.addFilterMsg) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        realtimeLogger.addFilterMsg(</div><div class="line">          <span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>] <span class="subst">$&#123;file&#125;</span> <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(args)&#125;</span>`</span></div><div class="line">        );</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        realtimeLogger.addFilterMsg(<span class="string">`[<span class="subst">$&#123;VERSION&#125;</span>] <span class="subst">$&#123;file&#125;</span>`</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方便将页面名字自动打印</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getLogger</span>(<span class="params">fileName: string</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">DEBUG</span>: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">      DEBUG(fileName, ...args);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">RUN</span>: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">      RUN(fileName, ...args);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">ERROR</span>: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">      ERROR(fileName, ...args);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过这样的方式，我们在一个页面中使用日志的时候，可以这么使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; getLogger &#125; <span class="keyword">from</span> <span class="string">"./log"</span>;</div><div class="line"><span class="keyword">const</span> PAGE_MANE = <span class="string">"page_name"</span>;</div><div class="line"><span class="keyword">const</span> logger = getLogger(PAGE_MANE);</div></pre></td></tr></table></figure><h3 id="autolog-behavior"><a href="#autolog-behavior" class="headerlink" title="autolog-behavior"></a>autolog-behavior</h3><p>现在有了日志组件，我们需要在足够多的地方记录日志，才能在问题出现的时候及时进行定位。一般来说，我们需要在每个方法在被调用的时候都打印一个日志，所以这里封装了一个 autolog-behavior 的方式，每个页面（需要是 Component 方式）中只需要引入这个 behavior，就可以在每个方法调用的时候，打印日志：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// autolog-behavior.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Log <span class="keyword">from</span> <span class="string">"../utils/log"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 本 Behavior 会在小程序 methods 中每个方法调用前添加一个 Log 说明</div><div class="line"> * 需要在 Component 的 data 属性中添加 PAGE_NAME，用于描述当前页面</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Behavior(&#123;</div><div class="line">  definitionFilter(defFields) &#123;</div><div class="line">    <span class="comment">// 获取定义的方法</span></div><div class="line">    <span class="built_in">Object</span>.keys(defFields.methods || &#123;&#125;).forEach(<span class="function"><span class="params">methodName</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> originMethod = defFields.methods![methodName];</div><div class="line">      <span class="comment">// 遍历更新每个方法</span></div><div class="line">      defFields.methods![methodName] = <span class="function"><span class="keyword">function</span>(<span class="params">ev, ...args</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ev &amp;&amp; ev.target &amp;&amp; ev.currentTarget &amp;&amp; ev.currentTarget.dataset) &#123;</div><div class="line">          <span class="comment">// 如果是事件类型，则只需要记录 dataset 数据</span></div><div class="line">          Log.RUN(defFields.data.PAGE_NAME, <span class="string">`<span class="subst">$&#123;methodName&#125;</span> invoke, event dataset = `</span>, ev.currentTarget.dataset, <span class="string">"params = "</span>, ...args);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 其他情况下，则都记录日志</span></div><div class="line">          Log.RUN( defFields.data.PAGE_NAME, <span class="string">`<span class="subst">$&#123;methodName&#125;</span> invoke, params = `</span>, ev, ...args);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 触发原有的方法</span></div><div class="line">        originMethod.call(<span class="keyword">this</span>, ev, ...args);</div><div class="line">      &#125;;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们能看到，日志打印依赖了页面中定义了一个<code>PAGE_NAME</code>的 data 数据，所以我们在使用的时候可以这么处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; getLogger &#125; <span class="keyword">from</span> <span class="string">"../../utils/log"</span>;</div><div class="line"><span class="keyword">import</span> autologBehavior <span class="keyword">from</span> <span class="string">"../../behaviors/autolog-behavior"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> PAGE_NAME = <span class="string">"page_name"</span>;</div><div class="line"><span class="keyword">const</span> logger = getLogger(PAGE_NAME);</div><div class="line"></div><div class="line">Component(&#123;</div><div class="line">  <span class="attr">behaviors</span>: [autologBehavior],</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    PAGE_NAME,</div><div class="line">    <span class="comment">// 其他数据</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    <span class="comment">// 定义的方法会在调用的时候自动打印日志</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><p>页面如何使用 Behavior<br>看看<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html" target="_blank" rel="external">官方文档</a>：事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用<code>Component</code>构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应<code>json</code>文件中包含<code>usingComponents</code>定义段。</p></blockquote><p>完整的项目可以参考<a href="https://github.com/godbasin/wxapp-typescript-demo" target="_blank" rel="external">wxapp-typescript-demo</a>。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.html" target="_blank" rel="external">LogManager</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/realtimelog/" target="_blank" rel="external">实时日志</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html" target="_blank" rel="external">Component构造器</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" target="_blank" rel="external">behaviors</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><hr><p>使用自定义组件的方式来写页面，有特别多好用的技巧，behavior 就是其中一个比较重要的能力，大家可以发挥自己的想象力来实现很多奇妙的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序定位问题也是一大难题，而官方提供了 LogManager 和实时日志，这两个能力是如何结合使用、是否还有更便捷的方式来使用呢？&lt;br&gt;
    
    </summary>
    
      <category term="小程序双皮奶" scheme="https://godbasin.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8C%E7%9A%AE%E5%A5%B6/"/>
    
    
      <category term="教程" scheme="https://godbasin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
